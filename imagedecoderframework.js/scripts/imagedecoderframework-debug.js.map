{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/imagedecoderexports.js","src/cesiumimagedecoder/_cesiumfrustumcalculator.js","src/cesiumimagedecoder/_cesiumimagedecoderlayermanager.js","src/cesiumimagedecoder/canvasimageryprovider.js","src/cesiumimagedecoder/imagedecoderimageryprovider.js","src/imagedecoder/imagedecoder.js","src/imagedecoder/imagedecoderhelpers/decodejob.js","src/imagedecoder/imagedecoderhelpers/decodejobspool.js","src/imagedecoder/imagedecoderhelpers/frustumrequestsprioritizer.js","src/imagedecoder/imagedecoderhelpers/imageHelperFunctions.js","src/imagedecoder/imagedecoderhelpers/linkedlist.js","src/imagedecoder/imagedecoderworkers/sendimageparameterstomaster.js","src/imagedecoder/imagedecoderworkers/workerproxyfetchmanager.js","src/imagedecoder/imagedecoderworkers/workerproxyimagedecoder.js","src/imagedecoder/imagedecoderworkers/workerproxypixelsdecoder.js","src/imagedecoder/viewerimagedecoder.js","src/leafletimagedecoder/imagedecoderregionlayer.js","src/leafletimagedecoder/leafletfrustumcalculator.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"imagedecoderframework-debug.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nmodule.exports.ViewerImageDecoder = require('viewerimagedecoder.js');\r\nmodule.exports.ImageDecoder = require('imagedecoder.js');\r\nmodule.exports.ImageDecoderImageryProvider = require('imagedecoderimageryprovider.js');\r\nmodule.exports.CesiumImageDecoderLayerManager = require('_cesiumimagedecoderlayermanager.js');\r\nmodule.exports.ImageDecoderRegionLayer = require('imagedecoderregionlayer.js');","'use strict';\r\n\r\nmodule.exports = calculateFrustum;\r\n\r\n/* global Cesium: false */\r\n\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\n\r\nvar MAX_RECURSIVE_LEVEL_ON_FAILED_TRANSFORM = 4;\r\n\r\nfunction calculateFrustum(cesiumWidget) {\r\n    var screenSize = {\r\n        x: cesiumWidget.scene.canvas.width,\r\n        y: cesiumWidget.scene.canvas.height\r\n    };\r\n    \r\n    var points = [];\r\n    searchBoundingPoints(\r\n        0, 0, screenSize.x, screenSize.y, points, cesiumWidget, /*recursive=*/0);\r\n\r\n    var frustumRectangle = Cesium.Rectangle.fromCartographicArray(points);\r\n\r\n    var frustumData = imageHelperFunctions.calculateFrustum2DFromBounds(\r\n        frustumRectangle, screenSize);\r\n                \r\n    return frustumData;\r\n}\r\n    \r\nfunction searchBoundingPoints(\r\n    minX, minY, maxX, maxY, points, cesiumWidget, recursiveLevel) {\r\n    \r\n    var transformedPoints = 0;\r\n    transformedPoints += transformAndAddPoint(\r\n        minX, minY, cesiumWidget, points);\r\n    transformedPoints += transformAndAddPoint(\r\n        maxX, minY, cesiumWidget, points);\r\n    transformedPoints += transformAndAddPoint(\r\n        minX, maxY, cesiumWidget, points);\r\n    transformedPoints += transformAndAddPoint(\r\n        maxX, maxY, cesiumWidget, points);\r\n\r\n    var maxLevel = MAX_RECURSIVE_LEVEL_ON_FAILED_TRANSFORM;\r\n    \r\n    if (transformedPoints === 4 || recursiveLevel >= maxLevel) {\r\n        return;\r\n    }\r\n    \r\n    ++recursiveLevel;\r\n    \r\n    var middleX = (minX + maxX) / 2;\r\n    var middleY = (minY + maxY) / 2;\r\n    \r\n    searchBoundingPoints(\r\n        minX, minY, middleX, middleY, points, cesiumWidget, recursiveLevel);\r\n\r\n    searchBoundingPoints(\r\n        minX, middleY, middleX, maxY, points, cesiumWidget, recursiveLevel);\r\n\r\n    searchBoundingPoints(\r\n        middleX, minY, maxX, middleY, points, cesiumWidget, recursiveLevel);\r\n\r\n    searchBoundingPoints(\r\n        middleX, middleY, maxX, maxY, points, cesiumWidget, recursiveLevel);\r\n}\r\n\r\nfunction transformAndAddPoint(x, y, cesiumWidget, points) {\r\n    \r\n    var screenPoint = new Cesium.Cartesian2(x, y);\r\n    var ellipsoid = cesiumWidget.scene.mapProjection.ellipsoid;\r\n    var point3D = cesiumWidget.scene.camera.pickEllipsoid(screenPoint, ellipsoid);\r\n    \r\n    if (point3D === undefined) {\r\n        return 0;\r\n    }\r\n\r\n    var cartesian = ellipsoid.cartesianToCartographic(point3D);\r\n    if (cartesian === undefined) {\r\n        return 0;\r\n    }\r\n    \r\n    points.push(cartesian);\r\n    return 1;\r\n}","'use strict';\r\n\r\nmodule.exports = CesiumImageDecoderLayerManager;\r\n\r\nvar CanvasImageryProvider = require('canvasimageryprovider.js');\r\nvar ViewerImageDecoder = require('viewerimagedecoder.js');\r\nvar CesiumFrustumCalculator = require('_cesiumfrustumcalculator.js');\r\n\r\n/* global Cesium: false */\r\n\r\nfunction CesiumImageDecoderLayerManager(options) {\r\n    this._options = Object.create(options);\r\n    this._options.minFunctionCallIntervalMilliseconds =\r\n        options.minFunctionCallIntervalMilliseconds || 100;\r\n    this._url = options.url;\r\n\r\n    this._targetCanvas = document.createElement('canvas');\r\n    this._imageryProvider = new CanvasImageryProvider(this._targetCanvas);\r\n    this._imageryLayer = new Cesium.ImageryLayer(this._imageryProvider);\r\n\r\n    this._canvasUpdatedCallbackBound = this._canvasUpdatedCallback.bind(this);\r\n    \r\n    this._image = new ViewerImageDecoder(\r\n        this._canvasUpdatedCallbackBound,\r\n        this._options);\r\n    \r\n    this._image.setTargetCanvas(this._targetCanvas);\r\n    \r\n    this._updateFrustumBound = this._updateFrustum.bind(this);\r\n}\r\n\r\nCesiumImageDecoderLayerManager.prototype.setExceptionCallback = function setExceptionCallback(exceptionCallback) {\r\n    this._image.setExceptionCallback(exceptionCallback);\r\n};\r\n\r\nCesiumImageDecoderLayerManager.prototype.open = function open(widgetOrViewer) {\r\n    this._widget = widgetOrViewer;\r\n    this._layers = widgetOrViewer.scene.imageryLayers;\r\n    \r\n    this._image.open(this._url);\r\n    this._layers.add(this._imageryLayer);\r\n    \r\n    // NOTE: Is there an event handler to register instead?\r\n    // (Cesium's event controllers only expose keyboard and mouse\r\n    // events, but there is no event for frustum changed\r\n    // programmatically).\r\n    this._intervalHandle = setInterval(\r\n        this._updateFrustumBound,\r\n        500);\r\n};\r\n\r\nCesiumImageDecoderLayerManager.prototype.close = function close() {\r\n    this._image.close();\r\n    clearInterval(this._intervalHandle);\r\n\r\n    this._layers.remove(this._imageryLayer);\r\n};\r\n\r\nCesiumImageDecoderLayerManager.prototype.getImageryLayer = function getImageryLayer() {\r\n    return this._imageryLayer;\r\n};\r\n\r\nCesiumImageDecoderLayerManager.prototype._updateFrustum = function updateFrustum() {\r\n    var frustum = CesiumFrustumCalculator.calculateFrustum(this._widget);\r\n    if (frustum !== null) {\r\n        this._image.updateViewArea(frustum);\r\n    }\r\n};\r\n\r\nCesiumImageDecoderLayerManager.prototype._canvasUpdatedCallback = function canvasUpdatedCallback(newPosition) {\r\n    if (newPosition !== null) {\r\n        var rectangle = new Cesium.Rectangle(\r\n            newPosition.west,\r\n            newPosition.south,\r\n            newPosition.east,\r\n            newPosition.north);\r\n        \r\n        this._imageryProvider.setRectangle(rectangle);\r\n    }\r\n    \r\n    this._removeAndReAddLayer();\r\n};\r\n\r\nCesiumImageDecoderLayerManager.prototype._removeAndReAddLayer = function removeAndReAddLayer() {\r\n    var index = this._layers.indexOf(this._imageryLayer);\r\n    \r\n    if (index < 0) {\r\n        throw 'Layer was removed from viewer\\'s layers  without ' +\r\n            'closing layer manager. Use CesiumImageDecoderLayerManager.' +\r\n            'close() instead';\r\n    }\r\n    \r\n    this._layers.remove(this._imageryLayer, /*destroy=*/false);\r\n    this._layers.add(this._imageryLayer, index);\r\n};","'use strict';\r\n\r\nmodule.exports = CanvasImageryProvider;\r\n\r\n/* global Cesium: false */\r\n/* global DeveloperError: false */\r\n/* global Credit: false */\r\n\r\n/**\r\n * Provides a Single Canvas imagery tile.  The image is assumed to use a\r\n * {@link GeographicTilingScheme}.\r\n *\r\n * @alias CanvasImageryProvider\r\n * @constructor\r\n *\r\n * @param {canvas} Canvas for the tile.\r\n * @param {Object} options Object with the following properties:\r\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\r\n *\r\n * @see ArcGisMapServerImageryProvider\r\n * @see BingMapsImageryProvider\r\n * @see GoogleEarthImageryProvider\r\n * @see OpenStreetMapImageryProvider\r\n * @see TileMapServiceImageryProvider\r\n * @see WebMapServiceImageryProvider\r\n */\r\nfunction CanvasImageryProvider(canvas, options) {\r\n    if (options === undefined) {\r\n        options = {};\r\n    }\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (canvas === undefined) {\r\n        throw new DeveloperError('canvas is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    this._canvas = canvas;\r\n\r\n    this._errorEvent = new Event('CanvasImageryProviderStatus');\r\n\r\n    this._ready = false;\r\n\r\n    var credit = options.credit;\r\n    if (typeof credit === 'string') {\r\n        credit = new Credit(credit);\r\n    }\r\n    this._credit = credit;\r\n}\r\n\r\nCanvasImageryProvider.prototype = {\r\n    /**\r\n     * Gets the width of each tile, in pixels. This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get tileWidth() {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!this._ready) {\r\n                    throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            return this._canvas.width;\r\n    },\r\n\r\n    /**\r\n     * Gets the height of each tile, in pixels.  This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get tileHeight() {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!this._ready) {\r\n                    throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            return this._canvas.height;\r\n    },\r\n\r\n    /**\r\n     * Gets the maximum level-of-detail that can be requested.  This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get maximumLevel() {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!this._ready) {\r\n                    throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            return 0;\r\n    },\r\n\r\n    /**\r\n     * Gets the minimum level-of-detail that can be requested.  This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get minimumLevel() {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!this._ready) {\r\n                    throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            return 0;\r\n    },\r\n\r\n    /**\r\n     * Gets the tiling scheme used by this provider.  This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {TilingScheme}\r\n     * @readonly\r\n     */\r\n    get tilingScheme() {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!this._ready) {\r\n                    throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            return this._tilingScheme;\r\n    },\r\n\r\n    /**\r\n     * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Rectangle}\r\n     * @readonly\r\n     */\r\n    get rectangle() {\r\n            return this._tilingScheme.rectangle;\r\n    },\r\n\r\n    /**\r\n     * Gets the tile discard policy.  If not undefined, the discard policy is responsible\r\n     * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\r\n     * returns undefined, no tiles are filtered.  This function should\r\n     * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {TileDiscardPolicy}\r\n     * @readonly\r\n     */\r\n    get tileDiscardPolicy() {\r\n            //>>includeStart('debug', pragmas.debug);\r\n            if (!this._ready) {\r\n                    throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');\r\n            }\r\n            //>>includeEnd('debug');\r\n\r\n            return undefined;\r\n    },\r\n\r\n    /**\r\n     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\r\n     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\r\n     * are passed an instance of {@link TileProviderError}.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Event}\r\n     * @readonly\r\n     */\r\n    get errorEvent() {\r\n            return this._errorEvent;\r\n    },\r\n\r\n    /**\r\n     * Gets a value indicating whether or not the provider is ready for use.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Boolean}\r\n     * @readonly\r\n     */\r\n    get ready() {\r\n            return this._ready;\r\n    },\r\n\r\n    /**\r\n     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\r\n     * the source of the imagery.  This function should not be called before {@link CanvasImageryProvider#ready} returns true.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Credit}\r\n     * @readonly\r\n     */\r\n    get credit() {\r\n            return this._credit;\r\n    },\r\n\r\n    /**\r\n     * Gets a value indicating whether or not the images provided by this imagery provider\r\n     * include an alpha channel.  If this property is false, an alpha channel, if present, will\r\n     * be ignored.  If this property is true, any images without an alpha channel will be treated\r\n     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\r\n     * and texture upload time are reduced.\r\n     * @memberof CanvasImageryProvider.prototype\r\n     * @type {Boolean}\r\n     * @readonly\r\n     */\r\n    get hasAlphaChannel() {\r\n            return true;\r\n    }\r\n};\r\n\r\nCanvasImageryProvider.prototype.setRectangle = function setRectangle(rectangle) {\r\n    \r\n    this._tilingScheme = new Cesium.GeographicTilingScheme({\r\n        rectangle: rectangle,\r\n        numberOfLevelZeroTilesX: 1,\r\n        numberOfLevelZeroTilesY: 1\r\n    });\r\n    \r\n    if (!this._ready) {\r\n        this._ready = true;\r\n        Cesium.TileProviderError.handleSuccess(this._errorEvent);\r\n    }\r\n};\r\n\r\nCanvasImageryProvider.prototype.getTileWidth = function getTileWidth() {\r\n    return this.tileWidth;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getTileHeight = function getTileHeight() {\r\n    return this.tileHeight;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getMaximumLevel = function getMaximumLevel() {\r\n    return this.maximumLevel;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getMinimumLevel = function getMinimumLevel() {\r\n    return this.minimumLevel;\r\n};\r\n\r\nCanvasImageryProvider.prototype.isReady = function isReady() {\r\n    return this.ready;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getCredit = function getCredit() {\r\n    return this.credit;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getRectangle = function getRectangle() {\r\n    return this.tilingScheme.rectangle;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getTilingScheme = function getTilingScheme() {\r\n    return this.tilingScheme;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getTileDiscardPolicy = function getTileDiscardPolicy() {\r\n    return this.tileDiscardPolicy;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getErrorEvent = function getErrorEvent() {\r\n    return this.errorEvent;\r\n};\r\n\r\nCanvasImageryProvider.prototype.getHasAlphaChannel = function getHasAlphaChannel() {\r\n    return this.hasAlphaChannel;\r\n};\r\n\r\n/**\r\n * Gets the credits to be displayed when a given tile is displayed.\r\n *\r\n * @param {Number} x The tile X coordinate.\r\n * @param {Number} y The tile Y coordinate.\r\n * @param {Number} level The tile level;\r\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\r\n *\r\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\r\n */\r\nCanvasImageryProvider.prototype.getTileCredits = function(x, y, level) {\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Requests the image for a given tile.  This function should\r\n * not be called before {@link CanvasImageryProvider#ready} returns true.\r\n *\r\n * @param {Number} x The tile X coordinate.\r\n * @param {Number} y The tile Y coordinate.\r\n * @param {Number} level The tile level.\r\n * @returns {Promise} A promise for the image that will resolve when the image is available, or\r\n *          undefined if there are too many active requests to the server, and the request\r\n *          should be retried later.  The resolved image may be either an\r\n *          Image or a Canvas DOM object.\r\n *\r\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\r\n */\r\nCanvasImageryProvider.prototype.requestImage = function(x, y, level) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!this._ready) {\r\n            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    return this._canvas;\r\n};\r\n\r\n/**\r\n * Picking features is not currently supported by this imagery provider, so this function simply returns\r\n * undefined.\r\n *\r\n * @param {Number} x The tile X coordinate.\r\n * @param {Number} y The tile Y coordinate.\r\n * @param {Number} level The tile level.\r\n * @param {Number} longitude The longitude at which to pick features.\r\n * @param {Number} latitude  The latitude at which to pick features.\r\n * @return {Promise} A promise for the picked features that will resolve when the asynchronous\r\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\r\n *                   instances.  The array may be empty if no features are found at the given location.\r\n *                   It may also be undefined if picking is not supported.\r\n */\r\nCanvasImageryProvider.prototype.pickFeatures = function() {\r\n        return undefined;\r\n};","'use strict';\r\n\r\nmodule.exports = ImageDecoderImageryProvider;\r\n\r\nvar WorkerProxyImageDecoder = require('workerproxyimagedecoder.js');\r\nvar CesiumFrustumCalculator = require('_cesiumfrustumcalculator.js');\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\n\r\n/* global Cesium: false */\r\n/* global DeveloperError: false */\r\n/* global Credit: false */\r\n/* global Promise: false */\r\n\r\n/**\r\n * Provides a ImageDecoder client imagery tile.  The image is assumed to use a\r\n * {@link GeographicTilingScheme}.\r\n *\r\n * @alias ImageDecoderImageryProvider\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {String} options.url The url for the tile.\r\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\r\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\r\n * @param {Object} [options.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.\r\n * @param {boolean} [options.adaptProportions] determines if to adapt the proportions of the rectangle provided to the image pixels proportions.\r\n *\r\n * @see ArcGisMapServerImageryProvider\r\n * @see BingMapsImageryProvider\r\n * @see GoogleEarthImageryProvider\r\n * @see OpenStreetMapImageryProvider\r\n * @see TileMapServiceImageryProvider\r\n * @see WebMapServiceImageryProvider\r\n */\r\nfunction ImageDecoderImageryProvider(options) {\r\n    if (options === undefined) {\r\n        options = {};\r\n    }\r\n\r\n    var url = options.url;\r\n    var adaptProportions = options.adaptProportions;\r\n    this._rectangle = options.rectangle;\r\n    this._proxy = options.proxy;\r\n    this._maxNumQualityLayers = options.maxNumQualityLayers;\r\n    this._updateFrustumInterval = 1000 || options.updateFrustumInterval;\r\n    this._credit = options.credit;\r\n    \r\n    if (typeof this._credit === 'string') {\r\n        this._credit = new Credit(this._credit);\r\n    }\r\n    \r\n    if (this._rectangle === undefined) {\r\n        this._rectangle = Cesium.Rectangle.fromDegrees(-180, -90, 180, 90);\r\n    }\r\n    \r\n    if (adaptProportions === undefined) {\r\n        adaptProportions = true;\r\n    }\r\n\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (url === undefined) {\r\n            throw new DeveloperError('url is required.');\r\n    }\r\n    //>>includeEnd('debug');\r\n\r\n    this._url = url;\r\n\r\n    this._tilingScheme = undefined;\r\n\r\n    this._tileWidth = 0;\r\n    this._tileHeight = 0;\r\n\r\n    this._errorEvent = new Event('ImageDecoderImageryProviderStatus');\r\n\r\n    this._ready = false;\r\n    this._statusCallback = null;\r\n    this._cesiumWidget = null;\r\n    this._updateFrustumIntervalHandle = null;\r\n    \r\n\r\n    var imageUrl = url;\r\n    if (this._proxy !== undefined) {\r\n        // NOTE: Is that the correct logic?\r\n        imageUrl = this._proxy.getURL(imageUrl);\r\n    }\r\n        \r\n    this._image = new WorkerProxyImageDecoder({\r\n        serverRequestPrioritizer: 'frustum',\r\n        decodePrioritizer: 'frustum'\r\n    });\r\n\r\n    this._url = imageUrl;\r\n}\r\n\r\nImageDecoderImageryProvider.prototype = {\r\n    /**\r\n     * Gets the URL of the ImageDecoder server (including target).\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n    get url() {\r\n        return this._url;\r\n    },\r\n\r\n    /**\r\n     * Gets the proxy used by this provider.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Proxy}\r\n     * @readonly\r\n     */\r\n    get proxy() {\r\n        return this._proxy;\r\n    },\r\n\r\n    /**\r\n     * Gets the width of each tile, in pixels. This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get tileWidth() {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!this._ready) {\r\n                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return this._tileWidth;\r\n    },\r\n\r\n    /**\r\n     * Gets the height of each tile, in pixels.  This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get tileHeight() {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!this._ready) {\r\n                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return this._tileHeight;\r\n    },\r\n\r\n    /**\r\n     * Gets the maximum level-of-detail that can be requested.  This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get maximumLevel() {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!this._ready) {\r\n                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return this._numResolutionLevels - 1;\r\n    },\r\n\r\n    /**\r\n     * Gets the minimum level-of-detail that can be requested.  This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Number}\r\n     * @readonly\r\n     */\r\n    get minimumLevel() {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!this._ready) {\r\n                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Gets the tiling scheme used by this provider.  This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {TilingScheme}\r\n     * @readonly\r\n     */\r\n    get tilingScheme() {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!this._ready) {\r\n            throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return this._tilingScheme;\r\n    },\r\n\r\n    /**\r\n     * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Rectangle}\r\n     * @readonly\r\n     */\r\n    get rectangle() {\r\n        return this._tilingScheme.rectangle;\r\n    },\r\n\r\n    /**\r\n     * Gets the tile discard policy.  If not undefined, the discard policy is responsible\r\n     * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\r\n     * returns undefined, no tiles are filtered.  This function should\r\n     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {TileDiscardPolicy}\r\n     * @readonly\r\n     */\r\n    get tileDiscardPolicy() {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!this._ready) {\r\n            throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        return undefined;\r\n    },\r\n\r\n    /**\r\n     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\r\n     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\r\n     * are passed an instance of {@link TileProviderError}.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Event}\r\n     * @readonly\r\n     */\r\n    get errorEvent() {\r\n        return this._errorEvent;\r\n    },\r\n\r\n    /**\r\n     * Gets a value indicating whether or not the provider is ready for use.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Boolean}\r\n     * @readonly\r\n     */\r\n    get ready() {\r\n        return this._ready;\r\n    },\r\n\r\n    /**\r\n     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\r\n     * the source of the imagery.  This function should not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Credit}\r\n     * @readonly\r\n     */\r\n    get credit() {\r\n        return this._credit;\r\n    },\r\n\r\n    /**\r\n     * Gets a value indicating whether or not the images provided by this imagery provider\r\n     * include an alpha channel.  If this property is false, an alpha channel, if present, will\r\n     * be ignored.  If this property is true, any images without an alpha channel will be treated\r\n     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\r\n     * and texture upload time are reduced.\r\n     * @memberof ImageDecoderImageryProvider.prototype\r\n     * @type {Boolean}\r\n     * @readonly\r\n     */\r\n    get hasAlphaChannel() {\r\n        return true;\r\n    }\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.setExceptionCallback =\r\n    function setExceptionCallback(exceptionCallback) {\r\n    \r\n    this._exceptionCallback = exceptionCallback;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.open = function open(widgetOrViewer) {\r\n    if (this._updateFrustumIntervalHandle !== null) {\r\n        throw new DeveloperError('Cannot set two parent viewers.');\r\n    }\r\n    \r\n    if (widgetOrViewer === undefined) {\r\n        throw new DeveloperError('widgetOrViewer should be given. It is ' +\r\n            'needed for frustum calculation for the priority mechanism');\r\n    }\r\n    \r\n    this._image.setStatusCallback(this._statusCallback.bind(this));\r\n    this._image.open(this._url);\r\n    \r\n    this._cesiumWidget = widgetOrViewer;\r\n    \r\n    this._updateFrustumIntervalHandle = setInterval(\r\n        this._setPriorityByFrustum.bind(this),\r\n        this._updateFrustumInterval);\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.close = function close() {\r\n    clearInterval(this._updateFrustumIntervalHandle);\r\n    this._image.close();\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getTileWidth = function getTileWidth() {\r\n    return this.tileWidth;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getTileHeight = function getTileHeight() {\r\n    return this.tileHeight;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getMaximumLevel = function getMaximumLevel() {\r\n    return this.maximumLevel;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getMinimumLevel = function getMinimumLevel() {\r\n    return this.minimumLevel;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getUrl = function getUrl() {\r\n    return this.url;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getProxy = function getProxy() {\r\n    return this.proxy;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.isReady = function isReady() {\r\n    return this.ready;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getCredit = function getCredit() {\r\n    return this.credit;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getRectangle = function getRectangle() {\r\n    return this.tilingScheme.rectangle;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getTilingScheme = function getTilingScheme() {\r\n    return this.tilingScheme;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getTileDiscardPolicy = function getTileDiscardPolicy() {\r\n    return this.tileDiscardPolicy;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getErrorEvent = function getErrorEvent() {\r\n    return this.errorEvent;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype.getHasAlphaChannel = function getHasAlphaChannel() {\r\n    return this.hasAlphaChannel;\r\n};\r\n\r\n/**\r\n * Gets the credits to be displayed when a given tile is displayed.\r\n *\r\n * @param {Number} x The tile X coordinate.\r\n * @param {Number} y The tile Y coordinate.\r\n * @param {Number} level The tile level;\r\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\r\n *\r\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\r\n */\r\nImageDecoderImageryProvider.prototype.getTileCredits = function(x, y, level) {\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Requests the image for a given tile.  This function should\r\n * not be called before {@link ImageDecoderImageryProvider#ready} returns true.\r\n *\r\n * @param {Number} x The tile X coordinate.\r\n * @param {Number} y The tile Y coordinate.\r\n * @param {Number} level The tile level.\r\n * @returns {Promise} A promise for the image that will resolve when the image is available, or\r\n *          undefined if there are too many active requests to the server, and the request\r\n *          should be retried later.  The resolved image may be either an\r\n *          Image or a Canvas DOM object.\r\n *\r\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\r\n */\r\nImageDecoderImageryProvider.prototype.requestImage = function(x, y, level) {\r\n    //>>includeStart('debug', pragmas.debug);\r\n    if (!this._ready) {\r\n        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');\r\n    }\r\n    //>>includeEnd('debug');\r\n    \r\n    var self = this;\r\n    \r\n    var numResolutionLevelsToCut = this._numResolutionLevels - level - 1;\r\n    \r\n    var minX = x * this._tileWidth;\r\n    var minY = y * this._tileHeight;\r\n    var maxXExclusive = (x + 1) * this._tileWidth;\r\n    var maxYExclusive = (y + 1) * this._tileHeight;\r\n    \r\n    var levelWidth = this._image.getLevelWidth(numResolutionLevelsToCut);\r\n    var levelHeight = this._image.getLevelHeight(numResolutionLevelsToCut);\r\n    \r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = this._tileWidth;\r\n    canvas.height = this._tileHeight;\r\n    \r\n    var context = canvas.getContext('2d');\r\n    context.clearRect(0, 0, this._tileWidth, this._tileHeight);\r\n    \r\n    if (minX >= levelWidth ||\r\n        minY >= levelHeight ||\r\n        maxXExclusive <= 0 ||\r\n        maxYExclusive <= 0) {\r\n        \r\n        return canvas;\r\n    }\r\n    \r\n    var offsetX = 0;\r\n    var offsetY = 0;\r\n    maxXExclusive = Math.min(maxXExclusive, levelWidth);\r\n    maxYExclusive = Math.min(maxYExclusive, levelHeight);\r\n    \r\n    if (minX < 0) {\r\n        offsetX = -minX;\r\n        minX = 0;\r\n    }\r\n    \r\n    if (minY < 0) {\r\n        offsetY = -minY;\r\n        minY = 0;\r\n    }\r\n    \r\n    var imagePartParams = {\r\n        minX: minX,\r\n        minY: minY,\r\n        maxXExclusive: maxXExclusive,\r\n        maxYExclusive: maxYExclusive,\r\n        numResolutionLevelsToCut: numResolutionLevelsToCut,\r\n        maxNumQualityLayers: this._maxNumQualityLayers,\r\n        \r\n        requestPriorityData: {\r\n            imageRectangle: this._rectangle\r\n        }\r\n    };\r\n    \r\n    var resolve, reject;\r\n    var requestPixelsPromise = new Promise(function(resolve_, reject_) {\r\n        resolve = resolve_;\r\n        reject = reject_;\r\n        \r\n        self._image.requestPixelsProgressive(\r\n            imagePartParams,\r\n            pixelsDecodedCallback,\r\n            terminatedCallback);\r\n    });\r\n    \r\n    function pixelsDecodedCallback(decoded) {\r\n        var partialTileWidth = decoded.width;\r\n        var partialTileHeight = decoded.height;\r\n\r\n        var canvasTargetX = offsetX + decoded.xInOriginalRequest;\r\n        var canvasTargetY = offsetY + decoded.yInOriginalRequest;\r\n        \r\n        if (partialTileWidth > 0 && partialTileHeight > 0) {\r\n            var imageData = context.getImageData(\r\n                canvasTargetX, canvasTargetY, partialTileWidth, partialTileHeight);\r\n                \r\n            imageData.data.set(decoded.pixels);\r\n            context.putImageData(imageData, canvasTargetX, canvasTargetY);\r\n        }\r\n    }\r\n\r\n    function terminatedCallback(isAborted) {\r\n        if (isAborted) {\r\n            reject('Fetch request or decode aborted');\r\n        } else {\r\n            resolve(canvas);\r\n        }\r\n    }\r\n\r\n    return requestPixelsPromise;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype._setPriorityByFrustum =\r\n    function setPriorityByFrustum() {\r\n    \r\n    if (!this._ready) {\r\n        return;\r\n    }\r\n    \r\n    var frustumData = CesiumFrustumCalculator.calculateFrustum(\r\n        this._cesiumWidget, this);\r\n    \r\n    if (frustumData === null) {\r\n        return;\r\n    }\r\n    \r\n    frustumData.imageRectangle = this.getRectangle();\r\n    frustumData.exactNumResolutionLevelsToCut = null;\r\n\r\n    this._image.setServerRequestPrioritizerData(frustumData);\r\n    this._image.setDecodePrioritizerData(frustumData);\r\n};\r\n\r\n/**\r\n * Picking features is not currently supported by this imagery provider, so this function simply returns\r\n * undefined.\r\n *\r\n * @param {Number} x The tile X coordinate.\r\n * @param {Number} y The tile Y coordinate.\r\n * @param {Number} level The tile level.\r\n * @param {Number} longitude The longitude at which to pick features.\r\n * @param {Number} latitude  The latitude at which to pick features.\r\n * @return {Promise} A promise for the picked features that will resolve when the asynchronous\r\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\r\n *                   instances.  The array may be empty if no features are found at the given location.\r\n *                   It may also be undefined if picking is not supported.\r\n */\r\nImageDecoderImageryProvider.prototype.pickFeatures = function() {\r\n        return undefined;\r\n};\r\n\r\nImageDecoderImageryProvider.prototype._statusCallback =\r\n    function internalStatusCallback(status) {\r\n    \r\n    if (status.exception !== null && this._exceptionCallback !== null) {\r\n        this._exceptionCallback(status.exception);\r\n    }\r\n\r\n    if (!status.isReady || this._ready) {\r\n        return;\r\n    }\r\n    \r\n    this._ready = status.isReady;\r\n    \r\n    // This is wrong if COD or COC exists besides main header COD\r\n    this._numResolutionLevels = this._image.getDefaultNumResolutionLevels();\r\n    this._maxNumQualityLayers = this._maxNumQualityLayers;\r\n    //this._numResolutionLevels = 1;\r\n        \r\n    this._tileWidth = this._image.getTileWidth();\r\n    this._tileHeight = this._image.getTileHeight();\r\n        \r\n    var bestLevel = this._numResolutionLevels - 1;\r\n    var levelZeroWidth = this._image.getLevelWidth(bestLevel);\r\n    var levelZeroHeight = this._image.getLevelHeight(bestLevel);\r\n    \r\n    var levelZeroTilesX = Math.ceil(levelZeroWidth / this._tileWidth);\r\n    var levelZeroTilesY = Math.ceil(levelZeroHeight / this._tileHeight);\r\n\r\n    imageHelperFunctions.fixBounds(\r\n        this._rectangle,\r\n        this._image,\r\n        this._adaptProportions);\r\n    var rectangleWidth = this._rectangle.east - this._rectangle.west;\r\n    var rectangleHeight = this._rectangle.north - this._rectangle.south;\r\n    \r\n    var bestLevelScale = 1 << bestLevel;\r\n    var pixelsWidthForCesium = this._tileWidth * levelZeroTilesX * bestLevelScale;\r\n    var pixelsHeightForCesium = this._tileHeight * levelZeroTilesY * bestLevelScale;\r\n    \r\n    // Cesium works with full tiles only, thus fix the geographic bounds so\r\n    // the pixels lies exactly on the original bounds\r\n    \r\n    var geographicWidthForCesium =\r\n        rectangleWidth * pixelsWidthForCesium / this._image.getLevelWidth();\r\n    var geographicHeightForCesium =\r\n        rectangleHeight * pixelsHeightForCesium / this._image.getLevelHeight();\r\n    \r\n    var fixedEast = this._rectangle.west + geographicWidthForCesium;\r\n    var fixedSouth = this._rectangle.north - geographicHeightForCesium;\r\n    \r\n    this._tilingSchemeParams = {\r\n        west: this._rectangle.west,\r\n        east: fixedEast,\r\n        south: fixedSouth,\r\n        north: this._rectangle.north,\r\n        levelZeroTilesX: levelZeroTilesX,\r\n        levelZeroTilesY: levelZeroTilesY,\r\n        maximumLevel: bestLevel\r\n    };\r\n    \r\n    this._tilingScheme = createTilingScheme(this._tilingSchemeParams);\r\n        \r\n    Cesium.TileProviderError.handleSuccess(this._errorEvent);\r\n};\r\n\r\nfunction createTilingScheme(params) {\r\n    var geographicRectangleForCesium = new Cesium.Rectangle(\r\n        params.west, params.south, params.east, params.north);\r\n    \r\n    var tilingScheme = new Cesium.GeographicTilingScheme({\r\n        rectangle: geographicRectangleForCesium,\r\n        numberOfLevelZeroTilesX: params.levelZeroTilesX,\r\n        numberOfLevelZeroTilesY: params.levelZeroTilesY\r\n    });\r\n    \r\n    return tilingScheme;\r\n}","'use strict';\r\n\r\nmodule.exports = ImageDecoder;\r\n\r\nvar WorkerProxyFetchManager = require('workerproxyfetchmanager.js');\r\nvar imageHelperFunctions = require('imageHelperFunctions.js');\r\nvar DecodeJobsPool = require('decodejobspool.js');\r\nvar WorkerProxyPixelsDecoder = require('workerproxypixelsdecoder.js');\r\n\r\n/* global console: false */\r\n/* global Promise: false */\r\n\r\nfunction ImageDecoder(imageImplementationClassName, options) {\r\n    options = options || {};\r\n    var decodeWorkersLimit = options.workersLimit || 5;\r\n    \r\n    this._tileWidth = options.tileWidth || 256;\r\n    this._tileHeight = options.tileHeight || 256;\r\n    this._showLog = !!options.showLog;\r\n    \r\n    if (this._showLog) {\r\n        // Old IE\r\n        throw 'showLog is not supported on this browser';\r\n    }\r\n\r\n    this._sizesParams = null;\r\n    this._sizesCalculator = null;\r\n    this._requestHandles = [];\r\n    this._decoders = [];\r\n    this._imageImplementationClassName = imageImplementationClassName;\r\n    this._imageImplementation = imageHelperFunctions.getImageImplementation(imageImplementationClassName);\r\n    this._fetchManager = new WorkerProxyFetchManager(\r\n        imageImplementationClassName, options);\r\n    \r\n    var decodeScheduler = imageHelperFunctions.createScheduler(\r\n        this._showLog,\r\n        options.decodePrioritizer,\r\n        'decode',\r\n        this._createDecoder.bind(this),\r\n        decodeWorkersLimit);\r\n    \r\n    this._decodePrioritizer = decodeScheduler.prioritizer;\r\n\r\n    this._nonMovableRequestsDecodeJobsPool = new DecodeJobsPool(\r\n        this._fetchManager,\r\n        decodeScheduler.scheduler,\r\n        this._tileWidth,\r\n        this._tileHeight,\r\n        /*onlyWaitForDataAndDecode=*/false);\r\n        \r\n    this._movableRequestsDecodeJobsPool = new DecodeJobsPool(\r\n        this._fetchManager,\r\n        decodeScheduler.scheduler,\r\n        this._tileWidth,\r\n        this._tileHeight,\r\n        /*onlyWaitForDataAndDecode=*/true);\r\n}\r\n\r\nImageDecoder.prototype.setStatusCallback = function setStatusCallback(statusCallback) {\r\n    this._statusCallback = statusCallback;\r\n    this._fetchManager.setStatusCallback(statusCallback);\r\n};\r\n    \r\nImageDecoder.prototype.setServerRequestPrioritizerData =\r\n    function setServerRequestPrioritizerData(prioritizerData) {\r\n    \r\n    this._fetchManager.setServerRequestPrioritizerData(\r\n        prioritizerData);\r\n};\r\n\r\nImageDecoder.prototype.setDecodePrioritizerData =\r\n    function setDecodePrioritizerData(prioritizerData) {\r\n    \r\n    if (this._decodePrioritizer === null) {\r\n        throw 'No decode prioritizer has been set';\r\n    }\r\n    \r\n    if (this._showLog) {\r\n        console.log('setDecodePrioritizerData(' + prioritizerData + ')');\r\n    }\r\n    \r\n    var prioritizerDataModified = Object.create(prioritizerData);\r\n    prioritizerDataModified.image = this;\r\n    \r\n    this._decodePrioritizer.setPrioritizerData(prioritizerDataModified);\r\n};\r\n\r\nImageDecoder.prototype.open = function open(url) {\r\n    this._fetchManager.open(url);\r\n};\r\n\r\nImageDecoder.prototype.close = function close(closedCallback) {\r\n    for (var i = 0; i < this._decoders.length; ++i) {\r\n        this._decoders[i].terminate();\r\n    }\r\n\r\n    this._fetchManager.close(closedCallback);\r\n};\r\n\r\nImageDecoder.prototype.getLevelWidth = function getLevelWidth(numResolutionLevelsToCut) {\r\n    validateSizesCalculator(this);\r\n    var width = this._sizesCalculator.getLevelWidth(\r\n        numResolutionLevelsToCut);\r\n\r\n    return width;\r\n};\r\n\r\nImageDecoder.prototype.getLevelHeight = function getLevelHeight(numResolutionLevelsToCut) {\r\n    validateSizesCalculator(this);\r\n    var height = this._sizesCalculator.getLevelHeight(\r\n        numResolutionLevelsToCut);\r\n\r\n    return height;\r\n};\r\n\r\nImageDecoder.prototype.getTileWidth = function getTileWidth() {\r\n    validateSizesCalculator(this);\r\n    return this._tileWidth;\r\n};\r\n\r\nImageDecoder.prototype.getTileHeight = function getTileHeight() {\r\n    validateSizesCalculator(this);\r\n    return this._tileHeight;\r\n};\r\n\r\nImageDecoder.prototype.getDefaultNumResolutionLevels = function getDefaultNumResolutionLevels() {\r\n    validateSizesCalculator(this);\r\n    var numLevels = this._sizesCalculator.getDefaultNumResolutionLevels();\r\n    \r\n    return numLevels;\r\n};\r\n\r\nImageDecoder.prototype.getDefaultNumQualityLayers = function getDefaultNumQualityLayers() {\r\n    validateSizesCalculator(this);\r\n    var numLayers = this._sizesCalculator.getDefaultNumQualityLayers();\r\n    \r\n    return numLayers;\r\n};\r\n\r\nImageDecoder.prototype.createMovableRequestHandle = function createMovableRequestHandle(\r\n    createdCallback) {\r\n    \r\n    validateSizesCalculator(this);\r\n    \r\n    var self = this;\r\n    \r\n    function requestHandleCreated(requestHandle) {\r\n        self._requestHandles[requestHandle] = {\r\n            decodeJobsListenerHandle: null\r\n        };\r\n        \r\n        createdCallback(requestHandle);\r\n    }\r\n    \r\n    this._fetchManager.createMovableRequestHandle(\r\n        requestHandleCreated);\r\n};\r\n\r\nImageDecoder.prototype.requestPixels = function requestPixels(imagePartParams) {\r\n    validateSizesCalculator(this);\r\n    \r\n    var level = imagePartParams.numResolutionLevelsToCut;\r\n    var levelWidth = this._sizesCalculator.getLevelWidth(level);\r\n    var levelHeight = this._sizesCalculator.getLevelHeight(level);\r\n    \r\n    var resolve, reject;\r\n    var accumulatedResult = {};\r\n    \r\n    var self = this;\r\n    var promise = new Promise(startPromise);\r\n    return promise;\r\n    \r\n    function startPromise(resolve_, reject_) {\r\n        resolve = resolve_;\r\n        reject = reject_;\r\n        \r\n        self._nonMovableRequestsDecodeJobsPool.forkDecodeJobs(\r\n            imagePartParams,\r\n            internalCallback,\r\n            internalTerminatedCallback,\r\n            levelWidth,\r\n            levelHeight,\r\n            /*isProgressive=*/false);\r\n    }\r\n    \r\n    function internalCallback(decodedData) {\r\n        copyPixelsToAccumulatedResult(decodedData, accumulatedResult);\r\n    }\r\n    \r\n    function internalTerminatedCallback(isAborted) {\r\n        if (isAborted) {\r\n            reject('Request was aborted due to failure or priority');\r\n        } else {\r\n            resolve(accumulatedResult);\r\n        }\r\n    }\r\n};\r\n\r\nImageDecoder.prototype.requestPixelsProgressive = function requestPixelsProgressive(\r\n    imagePartParams,\r\n    callback,\r\n    terminatedCallback,\r\n    imagePartParamsNotNeeded,\r\n    movableRequestHandleToChange) {\r\n    \r\n    validateSizesCalculator(this);\r\n    \r\n    var level = imagePartParams.numResolutionLevelsToCut;\r\n    var levelWidth = this._sizesCalculator.getLevelWidth(level);\r\n    var levelHeight = this._sizesCalculator.getLevelHeight(level);\r\n    \r\n    var requestHandleVars = null;\r\n    var decodeJobsPool;\r\n    if (movableRequestHandleToChange === undefined) {\r\n        decodeJobsPool = this._nonMovableRequestsDecodeJobsPool;\r\n    } else {\r\n        decodeJobsPool = this._movableRequestsDecodeJobsPool;\r\n        \r\n        requestHandleVars = this._requestHandles[\r\n            movableRequestHandleToChange];\r\n        \r\n        if (requestHandleVars === undefined) {\r\n            throw 'Request handle does not exist';\r\n        }\r\n        \r\n        this._fetchManager.moveRequest(\r\n            movableRequestHandleToChange, imagePartParams);\r\n    }\r\n    \r\n    var listenerHandle = decodeJobsPool.forkDecodeJobs(\r\n        imagePartParams,\r\n        callback,\r\n        terminatedCallback,\r\n        levelWidth,\r\n        levelHeight,\r\n        /*isProgressive=*/true,\r\n        imagePartParamsNotNeeded);\r\n        \r\n    if (movableRequestHandleToChange !== undefined &&\r\n        requestHandleVars.decodeJobsListenerHandle !== null) {\r\n        \r\n        // Unregister after forked new jobs, so no termination occurs meanwhile\r\n        decodeJobsPool.unregisterForkedJobs(\r\n            requestHandleVars.decodeJobsListenerHandle);\r\n    }\r\n    \r\n    if (requestHandleVars !== null) {\r\n        requestHandleVars.decodeJobsListenerHandle = listenerHandle;\r\n    }\r\n};\r\n\r\nImageDecoder.prototype.reconnect = function reconnect() {\r\n    this._fetchManager.reconnect();\r\n};\r\n\r\nImageDecoder.prototype._getSizesCalculator = function getSizesCalculator() {\r\n    validateSizesCalculator(this);\r\n    \r\n    return this._sizesCalculator;\r\n};\r\n\r\nImageDecoder.prototype._getSizesParams = function getSizesParams() {\r\n    if (this._sizesParams === null) {\r\n        this._sizesParams = {\r\n            imageParams: this._fetchManager.getSizesParams(),\r\n            applicativeTileWidth: this._tileWidth,\r\n            applicativeTileHeight:  this._tileHeight\r\n        };\r\n    }\r\n    \r\n    return this._sizesParams;\r\n};\r\n\r\nImageDecoder.prototype._createDecoder = function createDecoder() {\r\n    var decoder = new WorkerProxyPixelsDecoder(this._imageImplementationClassName, this._options);\r\n    this._decoders.push(decoder);\r\n    \r\n    return decoder;\r\n};\r\n\r\nfunction validateSizesCalculator(self) {\r\n    if (self._sizesCalculator !== null) {\r\n        return;\r\n    }\r\n    \r\n    var sizesParams = self._getSizesParams();\r\n    self._sizesCalculator = self._imageImplementation.createImageParamsRetriever(\r\n        sizesParams.imageParams);\r\n}\r\n\r\nfunction copyPixelsToAccumulatedResult(decodedData, accumulatedResult) {\r\n    var bytesPerPixel = 4;\r\n    var sourceStride = decodedData.width * bytesPerPixel;\r\n    var targetStride =\r\n        decodedData.originalRequestWidth * bytesPerPixel;\r\n    \r\n    if (accumulatedResult.pixels === undefined) {\r\n        var size =\r\n            targetStride * decodedData.originalRequestHeight;\r\n            \r\n        accumulatedResult.pixels = new Uint8Array(size);\r\n        accumulatedResult.xInOriginalRequest = 0;\r\n        accumulatedResult.yInOriginalRequest = 0;\r\n        \r\n        var width = decodedData.originalRequestWidth;\r\n        accumulatedResult.originalRequestWidth = width;\r\n        accumulatedResult.width = width;\r\n\r\n        var height = decodedData.originalRequestHeight;\r\n        accumulatedResult.originalRequestHeight = height;\r\n        accumulatedResult.height = height;\r\n    }\r\n    \r\n    accumulatedResult.allRelevantBytesLoaded =\r\n        decodedData.allRelevantBytesLoaded;\r\n\r\n    var sourceOffset = 0;\r\n    var targetOffset =\r\n        decodedData.xInOriginalRequest * bytesPerPixel + \r\n        decodedData.yInOriginalRequest * targetStride;\r\n    \r\n    for (var i = 0; i < decodedData.height; ++i) {\r\n        var sourceSubArray = decodedData.pixels.subarray(\r\n            sourceOffset, sourceOffset + sourceStride);\r\n        \r\n        accumulatedResult.pixels.set(sourceSubArray, targetOffset);\r\n        \r\n        sourceOffset += sourceStride;\r\n        targetOffset += targetStride;\r\n    }\r\n}","'use strict';\r\n\r\nmodule.exports = DecodeJob;\r\n\r\nvar LinkedList = require('linkedlist.js');\r\n\r\nvar requestIdCounter = 0;\r\n\r\nfunction DecodeJob(\r\n    imagePartParams,\r\n    fetchManager,\r\n    decodeScheduler,\r\n    onlyWaitForDataAndDecode) {\r\n    \r\n    this._isAborted = false;\r\n    this._isTerminated = false;\r\n    this._isFetchRequestTerminated = false;\r\n    this._isFirstStage = true;\r\n    this._isManuallyAborted = false;\r\n\r\n    this._firstDecodeResult = null;\r\n    this._pendingDecodeResult = null;\r\n    this._activeSubJobs = 1;\r\n    this._imagePartParams = imagePartParams;\r\n    this._decodeScheduler = decodeScheduler;\r\n    this._jobSequenceId = 0;\r\n    this._lastFinishedJobSequenceId = -1;\r\n    this._progressiveStagesDone = 0;\r\n    this._listenersLinkedList = new LinkedList();\r\n    this._progressiveListenersCount = 0;\r\n    this._requestId = ++requestIdCounter;\r\n    this._allRelevantBytesLoaded = 0;\r\n    this._fetchManager = fetchManager;\r\n    this._startDecodeBound = this._startDecode.bind(this);\r\n    this._decodeAbortedBound = this._decodeAborted.bind(this);\r\n    \r\n    fetchManager.createRequest(\r\n        imagePartParams,\r\n        this,\r\n        this._dataReadyForDecode,\r\n        this._fetchTerminated,\r\n        onlyWaitForDataAndDecode,\r\n        this._requestId);\r\n}\r\n\r\nDecodeJob.prototype.registerListener = function registerListener(listenerHandle) {\r\n    var iterator = this._listenersLinkedList.add(listenerHandle);\r\n    \r\n    if (listenerHandle.isProgressive) {\r\n        ++this._progressiveListenersCount;\r\n        \r\n        if (this._progressiveListenersCount === 1) {\r\n            this._fetchManager.setIsProgressiveRequest(\r\n                this._requestId, true);\r\n        }\r\n    }\r\n    \r\n    var unregisterHandle = iterator;\r\n    return unregisterHandle;\r\n};\r\n\r\nDecodeJob.prototype.unregisterListener = function unregisterListener(unregisterHandle) {\r\n    var iterator = unregisterHandle;\r\n    var listenerHandle = this._listenersLinkedList.getValue(iterator);\r\n\r\n    this._listenersLinkedList.remove(unregisterHandle);\r\n    \r\n    if (listenerHandle.isProgressive) {\r\n        --this._progressiveListenersCount;\r\n    }\r\n    \r\n    if (this._listenersLinkedList.getCount() === 0) {\r\n        this._fetchManager.manualAbortNonMovableRequest(\r\n            this._requestId);\r\n        \r\n        this._isAborted = true;\r\n        this._isTerminated = true;\r\n        this._isFetchRequestTerminated = true;\r\n        this._isManuallyAborted = true;\r\n    } else if (this._progressiveListenersCount === 0) {\r\n        this._fetchManager.setIsProgressiveRequest(\r\n            this._requestId, false);\r\n    }\r\n};\r\n\r\nDecodeJob.prototype.getIsTerminated = function getIsTerminated() {\r\n    return this._isTerminated;\r\n};\r\n\r\nDecodeJob.prototype._dataReadyForDecode = function dataReadyForDecode(dataForDecode) {\r\n    if (this._isAbortedNoTermination() ||\r\n        this._listenersLinkedList.getCount() === 0) {\r\n        \r\n        // NOTE: Should find better way to clean job if listeners list\r\n        // is empty\r\n        \r\n        return;\r\n    }\r\n    \r\n    if (this._isFirstStage) {\r\n        this._firstDecodeResult = {\r\n            dataForDecode: dataForDecode\r\n        };\r\n    } else {\r\n        this._pendingDecodeResult = {\r\n            dataForDecode: dataForDecode\r\n        };\r\n    \r\n        if (this._isAlreadyScheduledNonFirstJob) {\r\n            return;\r\n        }\r\n        \r\n        this._isAlreadyScheduledNonFirstJob = true;\r\n    }\r\n    \r\n    if (this._isTerminated) {\r\n        throw 'Job has already been terminated';\r\n    }\r\n    \r\n    this._isFirstStage = false;\r\n    ++this._activeSubJobs;\r\n    \r\n    var jobContext = {\r\n        self: this,\r\n        imagePartParams: this._imagePartParams,\r\n        progressiveStagesDone: this._progressiveStagesDone\r\n    };\r\n    \r\n    this._decodeScheduler.enqueueJob(\r\n        this._startDecodeBound, jobContext, this._decodeAbortedBound);\r\n};\r\n\r\nDecodeJob.prototype._startDecode = function startDecode(decoder, jobContext) {\r\n    var decodeResult;\r\n    if (this._firstDecodeResult !== null) {\r\n        decodeResult = this._firstDecodeResult;\r\n        this._firstDecodeResult = null;\r\n    } else {\r\n        decodeResult = this._pendingDecodeResult;\r\n        this._pendingDecodeResult = null;\r\n        \r\n        this._isAlreadyScheduledNonFirstJob = false;\r\n    }\r\n    \r\n    jobContext.allRelevantBytesLoaded = decodeResult.dataForDecode.allRelevantBytesLoaded;\r\n    \r\n    if (this._isAbortedNoTermination()) {\r\n        --this._activeSubJobs;\r\n        this._decodeScheduler.jobDone(decoder, jobContext);\r\n        checkIfAllTerminated(this);\r\n        \r\n        return;\r\n    }\r\n    \r\n    var jobSequenceId = ++this._jobSequenceId;\r\n    \r\n    var params = this._imagePartParams;\r\n    var width = params.maxXExclusive - params.minX;\r\n    var height = params.maxYExclusive - params.minY;\r\n\r\n    decoder.decode(decodeResult.dataForDecode).then(pixelsDecodedCallbackInClosure);\r\n    \r\n    //var regionToParse = {\r\n    //    left: dataForDecode.headersCodestream.offsetX,\r\n    //    top: dataForDecode.headersCodestream.offsetY,\r\n    //    right: dataForDecode.headersCodestream.offsetX + width,\r\n    //    bottom: dataForDecode.headersCodestream.offsetY + height\r\n    //};\r\n    //\r\n    //jpxImageResource.parseCodestreamAsync(\r\n    //    jpxHeaderParseEndedCallback,\r\n    //    dataForDecode.headersCodestream.codestream,\r\n    //    0,\r\n    //    dataForDecode.headersCodestream.codestream.length,\r\n    //    { isOnlyParseHeaders: true });\r\n    //\r\n    //jpxImageResource.addPacketsDataToCurrentContext(dataForDecode.packetsData);\r\n    //\r\n    //jpxImageResource.decodeCurrentContextAsync(\r\n    //    pixelsDecodedCallbackInClosure, { regionToParse: regionToParse });\r\n        \r\n    var self = this;\r\n    \r\n    function pixelsDecodedCallbackInClosure(decodeResult) {\r\n        self._pixelsDecodedCallback(\r\n            decoder,\r\n            decodeResult,\r\n            jobSequenceId,\r\n            jobContext);\r\n        \r\n        self = null;\r\n    }\r\n};\r\n\r\nDecodeJob.prototype._pixelsDecodedCallback = function pixelsDecodedCallback(\r\n    decoder, decodeResult, jobSequenceId, jobContext) {\r\n    \r\n    this._decodeScheduler.jobDone(decoder, jobContext);\r\n    --this._activeSubJobs;\r\n    \r\n    var relevantBytesLoadedDiff =\r\n        jobContext.allRelevantBytesLoaded - this._allRelevantBytesLoaded;\r\n    this._allRelevantBytesLoaded = jobContext.allRelevantBytesLoaded;\r\n    \r\n    if (this._isAbortedNoTermination()) {\r\n        checkIfAllTerminated(this);\r\n        return;\r\n    }\r\n    \r\n    var lastFinished = this._lastFinishedJobSequenceId;\r\n    if (lastFinished > jobSequenceId) {\r\n        // Do not refresh pixels with lower quality layer than\r\n        // what was already returned\r\n        \r\n        checkIfAllTerminated(this);\r\n        return;\r\n    }\r\n    \r\n    this._lastFinishedJobSequenceId = jobSequenceId;\r\n    \r\n    var tileParams = this._imagePartParams;\r\n    \r\n    var iterator = this._listenersLinkedList.getFirstIterator();\r\n    while (iterator !== null) {\r\n        var listenerHandle = this._listenersLinkedList.getValue(iterator);\r\n        var originalParams = listenerHandle.imagePartParams;\r\n        \r\n        var offsetX = tileParams.minX - originalParams.minX;\r\n        var offsetY = tileParams.minY - originalParams.minY;\r\n        var width = originalParams.maxXExclusive - originalParams.minX;\r\n        var height = originalParams.maxYExclusive - originalParams.minY;\r\n        \r\n        listenerHandle.allRelevantBytesLoaded += relevantBytesLoadedDiff;\r\n        \r\n        var decodedOffsetted = {\r\n            originalRequestWidth: width,\r\n            originalRequestHeight: height,\r\n            xInOriginalRequest: offsetX,\r\n            yInOriginalRequest: offsetY,\r\n            \r\n            width: decodeResult.width,\r\n            height: decodeResult.height,\r\n            pixels: decodeResult.pixels,\r\n            \r\n            allRelevantBytesLoaded: listenerHandle.allRelevantBytesLoaded\r\n        };\r\n        \r\n        listenerHandle.callback(decodedOffsetted);\r\n        \r\n        iterator = this._listenersLinkedList.getNextIterator(iterator);\r\n    }\r\n\r\n    checkIfAllTerminated(this);\r\n};\r\n\r\nDecodeJob.prototype._fetchTerminated = function fetchTerminated(isAborted) {\r\n    if (this._isManuallyAborted) {\r\n        // This situation might occur if request has been terminated,\r\n        // but user's terminatedCallback has not been called yet. It\r\n        // happens on WorkerProxyFetchManager due to thread\r\n        // message delay.\r\n        \r\n        return;\r\n    }\r\n\r\n    if (this._isFetchRequestTerminated) {\r\n        throw 'Double termination of fetch request';\r\n    }\r\n    \r\n    this._isFetchRequestTerminated = true;\r\n    --this._activeSubJobs;\r\n    this._isAborted |= isAborted;\r\n    \r\n    checkIfAllTerminated(this);\r\n};\r\n\r\nDecodeJob.prototype._decodeAborted = function decodeAborted(jobContext) {\r\n    this._isAborted = true;\r\n    \r\n    if (this._firstDecodeResult !== null) {\r\n        this._firstDecodeResult = null;\r\n    } else {\r\n        this._pendingDecodeResult = null;\r\n        this._isAlreadyScheduledNonFirstJob = false;\r\n    }\r\n    \r\n    --this._activeSubJobs;\r\n    \r\n    checkIfAllTerminated(this);\r\n};\r\n\r\nDecodeJob.prototype._isAbortedNoTermination = function _isAbortedNoTermination() {\r\n    if (this._isManuallyAborted) {\r\n        return;\r\n    }\r\n    \r\n    if (this._isTerminated) {\r\n        throw 'Unexpected job state of terminated: Still runnin sub-jobs';\r\n    }\r\n    \r\n    return this._isAborted;\r\n};\r\n\r\n//function jpxHeaderParseEndedCallback() {\r\n//    // Do nothing\r\n//}\r\n\r\nfunction checkIfAllTerminated(self) {\r\n    if (self._activeSubJobs < 0) {\r\n        throw 'Inconsistent number of decode jobs';\r\n    }\r\n    \r\n    if (self._activeSubJobs > 0) {\r\n        return;\r\n    }\r\n    \r\n    if (self._isAlreadyScheduledNonFirstJob) {\r\n        throw 'Inconsistent isAlreadyScheduledNonFirstJob flag';\r\n    }\r\n    \r\n    self._isTerminated = true;\r\n    var linkedList = self._listenersLinkedList;\r\n    self._listenersLinkedList = null;\r\n\r\n    var iterator = linkedList.getFirstIterator();\r\n    \r\n    while (iterator !== null) {\r\n        var listenerHandle = linkedList.getValue(iterator);\r\n        listenerHandle.isAnyDecoderAborted |= self._isAborted;\r\n        \r\n        var remaining = --listenerHandle.remainingDecodeJobs;\r\n        if (remaining < 0) {\r\n            throw 'Inconsistent number of done requests';\r\n        }\r\n        \r\n        var isListenerDone = remaining === 0;\r\n        if (isListenerDone) {\r\n            listenerHandle.isTerminatedCallbackCalled = true;\r\n            listenerHandle.terminatedCallback(\r\n                listenerHandle.isAnyDecoderAborted);\r\n        }\r\n        \r\n        iterator = linkedList.getNextIterator(iterator);\r\n    }\r\n}","'use strict';\r\n\r\nmodule.exports = DecodeJobsPool;\r\n\r\nvar DecodeJob = require('decodejob.js');\r\n\r\nfunction DecodeJobsPool(\r\n    fetchManager,\r\n    decodeScheduler,\r\n    tileWidth,\r\n    tileHeight,\r\n    onlyWaitForDataAndDecode) {\r\n    \r\n    this._tileWidth = tileWidth;\r\n    this._tileHeight = tileHeight;\r\n    this._activeRequests = [];\r\n    this._onlyWaitForDataAndDecode = onlyWaitForDataAndDecode;\r\n    \r\n    this._fetchManager = fetchManager;\r\n    \r\n    this._decodeScheduler = decodeScheduler;\r\n}\r\n\r\nDecodeJobsPool.prototype.forkDecodeJobs = function forkDecodeJobs(\r\n    imagePartParams,\r\n    callback,\r\n    terminatedCallback,\r\n    levelWidth,\r\n    levelHeight,\r\n    isProgressive,\r\n    imagePartParamsNotNeeded) {\r\n    \r\n    var minX = imagePartParams.minX;\r\n    var minY = imagePartParams.minY;\r\n    var maxX = imagePartParams.maxXExclusive;\r\n    var maxY = imagePartParams.maxYExclusive;\r\n    var level = imagePartParams.numResolutionLevelsToCut || 0;\r\n    var layer = imagePartParams.maxNumQualityLayers;\r\n    var priorityData = imagePartParams.requestPriorityData;\r\n                \r\n    var isMinAligned =\r\n        minX % this._tileWidth === 0 && minY % this._tileHeight === 0;\r\n    var isMaxXAligned = maxX % this._tileWidth === 0 || maxX === levelWidth;\r\n    var isMaxYAligned = maxY % this._tileHeight === 0 || maxY === levelHeight;\r\n    var isOrderValid = minX < maxX && minY < maxY;\r\n    \r\n    if (!isMinAligned || !isMaxXAligned || !isMaxYAligned || !isOrderValid) {\r\n        throw 'imagePartParams for decoders is not aligned to ' +\r\n            'tile size or not in valid order';\r\n    }\r\n    \r\n    var requestsInLevel = getOrAddValue(this._activeRequests, level, []);\r\n    var requestsInQualityLayer = getOrAddValue(\r\n        requestsInLevel, imagePartParams.maxNumQualityLayers, []);\r\n        \r\n    var numTilesX = Math.ceil((maxX - minX) / this._tileWidth);\r\n    var numTilesY = Math.ceil((maxY - minY) / this._tileHeight);\r\n    \r\n    var listenerHandle = {\r\n        imagePartParams: imagePartParams,\r\n        callback: callback,\r\n        terminatedCallback: terminatedCallback,\r\n        remainingDecodeJobs: numTilesX * numTilesY,\r\n        isProgressive: isProgressive,\r\n        isAnyDecoderAborted: false,\r\n        isTerminatedCallbackCalled: false,\r\n        allRelevantBytesLoaded: 0,\r\n        unregisterHandles: []\r\n    };\r\n    \r\n    for (var x = minX; x < maxX; x += this._tileWidth) {\r\n        var requestsInX = getOrAddValue(requestsInQualityLayer, x, []);\r\n        var singleTileMaxX = Math.min(x + this._tileWidth, levelWidth);\r\n        \r\n        for (var y = minY; y < maxY; y += this._tileHeight) {\r\n            var singleTileMaxY = Math.min(y + this._tileHeight, levelHeight);\r\n            \r\n            var isTileNotNeeded = isUnneeded(\r\n                x,\r\n                y,\r\n                singleTileMaxX,\r\n                singleTileMaxY,\r\n                imagePartParamsNotNeeded);\r\n                \r\n            if (isTileNotNeeded) {\r\n                --listenerHandle.remainingDecodeJobs;\r\n                continue;\r\n            }\r\n        \r\n            var decodeJobContainer = getOrAddValue(requestsInX, y, {});\r\n            \r\n            if (decodeJobContainer.job === undefined ||\r\n                decodeJobContainer.job.getIsTerminated()) {\r\n                \r\n                var singleTileImagePartParams = {\r\n                    minX: x,\r\n                    minY: y,\r\n                    maxXExclusive: singleTileMaxX,\r\n                    maxYExclusive: singleTileMaxY,\r\n                    numResolutionLevelsToCut: level,\r\n                    maxNumQualityLayers: layer,\r\n                    requestPriorityData: priorityData\r\n                };\r\n                \r\n                decodeJobContainer.job = new DecodeJob(\r\n                    singleTileImagePartParams,\r\n                    this._fetchManager,\r\n                    this._decodeScheduler,\r\n                    this._onlyWaitForDataAndDecode);\r\n            }\r\n            \r\n            var unregisterHandle =\r\n                decodeJobContainer.job.registerListener(listenerHandle);\r\n            listenerHandle.unregisterHandles.push({\r\n                unregisterHandle: unregisterHandle,\r\n                job: decodeJobContainer.job\r\n            });\r\n        }\r\n    }\r\n    \r\n    if (!listenerHandle.isTerminatedCallbackCalled &&\r\n        listenerHandle.remainingDecodeJobs === 0) {\r\n        \r\n        listenerHandle.isTerminatedCallbackCalled = true;\r\n        listenerHandle.terminatedCallback(listenerHandle.isAnyDecoderAborted);\r\n    }\r\n    \r\n    return listenerHandle;\r\n};\r\n\r\nDecodeJobsPool.prototype.unregisterForkedJobs = function unregisterForkedJobs(listenerHandle) {\r\n    if (listenerHandle.remainingDecodeJobs === 0) {\r\n        // All jobs has already been terminated, no need to unregister\r\n        return;\r\n    }\r\n    \r\n    for (var i = 0; i < listenerHandle.unregisterHandles.length; ++i) {\r\n        var handle = listenerHandle.unregisterHandles[i];\r\n        if (handle.job.getIsTerminated()) {\r\n            continue;\r\n        }\r\n        \r\n        handle.job.unregisterListener(handle.unregisterHandle);\r\n    }\r\n};\r\n\r\nfunction isUnneeded(\r\n    minX, minY, maxX, maxY, imagePartParamsNotNeeded) {\r\n    \r\n    if (imagePartParamsNotNeeded === undefined) {\r\n        return false;\r\n    }\r\n    \r\n    for (var i = 0; i < imagePartParamsNotNeeded.length; ++i) {\r\n        var notNeeded = imagePartParamsNotNeeded[i];\r\n        var isInX = minX >= notNeeded.minX && maxX <= notNeeded.maxXExclusive;\r\n        var isInY = minY >= notNeeded.minY && maxY <= notNeeded.maxYExclusive;\r\n        \r\n        if (isInX && isInY) {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nfunction getOrAddValue(parentArray, index, defaultValue) {\r\n    var subArray = parentArray[index];\r\n    if (subArray === undefined) {\r\n        subArray = defaultValue;\r\n        parentArray[index] = subArray;\r\n    }\r\n    \r\n    return subArray;\r\n}","'use strict';\r\n\r\nmodule.exports = FrustumRequestsPrioritizer;\r\nvar PRIORITY_ABORT_NOT_IN_FRUSTUM = -1;\r\nvar PRIORITY_CALCULATION_FAILED = 0;\r\nvar PRIORITY_TOO_GOOD_RESOLUTION = 1;\r\nvar PRIORITY_NOT_IN_FRUSTUM = 2;\r\nvar PRIORITY_LOWER_RESOLUTION = 3;\r\n\r\nvar PRIORITY_MINORITY_IN_FRUSTUM = 4;\r\nvar PRIORITY_PARTIAL_IN_FRUSTUM = 5;\r\nvar PRIORITY_MAJORITY_IN_FRUSTUM = 6;\r\nvar PRIORITY_FULLY_IN_FRUSTUM = 7;\r\n\r\nvar ADD_PRIORITY_TO_LOW_QUALITY = 5;\r\n\r\nvar PRIORITY_HIGHEST = 13;\r\n\r\nvar log2 = Math.log(2);\r\n\r\nfunction FrustumRequestsPrioritizer(\r\n    isAbortRequestsNotInFrustum, isPrioritizeLowProgressiveStage) {\r\n    \r\n    this._frustumData = null;\r\n    this._isAbortRequestsNotInFrustum = isAbortRequestsNotInFrustum;\r\n    this._isPrioritizeLowProgressiveStage = isPrioritizeLowProgressiveStage;\r\n}\r\n\r\nObject.defineProperty(\r\n    FrustumRequestsPrioritizer.prototype, 'minimalLowQualityPriority', {\r\n        get: function minimalLowQualityPriority() {\r\n            return PRIORITY_MINORITY_IN_FRUSTUM + ADD_PRIORITY_TO_LOW_QUALITY;\r\n        }\r\n    }\r\n);\r\n    \r\nFrustumRequestsPrioritizer.prototype.setPrioritizerData = function setPrioritizerData(prioritizerData) {\r\n    this._frustumData = prioritizerData;\r\n};\r\n\r\nFrustumRequestsPrioritizer.prototype.getPriority = function getPriority(jobContext) {\r\n    var imagePartParams = jobContext.imagePartParams;\r\n    if (imagePartParams.requestPriorityData.overrideHighestPriority) {\r\n        return PRIORITY_HIGHEST;\r\n    }\r\n\r\n    var priority = this._getPriorityInternal(imagePartParams);\r\n    var isInFrustum = priority >= PRIORITY_MINORITY_IN_FRUSTUM;\r\n    \r\n    if (this._isAbortRequestsNotInFrustum && !isInFrustum) {\r\n        return PRIORITY_ABORT_NOT_IN_FRUSTUM;\r\n    }\r\n    \r\n    var prioritizeLowProgressiveStage = 0;\r\n    \r\n    if (this._isPrioritizeLowProgressiveStage && isInFrustum) {\r\n        if (jobContext.progressiveStagesDone === undefined) {\r\n            throw 'Missing progressive stage information';\r\n        }\r\n        \r\n        prioritizeLowProgressiveStage =\r\n            jobContext.progressiveStagesDone === 0 ? ADD_PRIORITY_TO_LOW_QUALITY :\r\n            jobContext.progressiveStagesDone === 1 ? 1 :\r\n            0;\r\n    }\r\n    \r\n    return priority + prioritizeLowProgressiveStage;\r\n};\r\n\r\nFrustumRequestsPrioritizer.prototype._getPriorityInternal = function getPriorityInternal(imagePartParams) {\r\n    if (this._frustumData === null) {\r\n        return PRIORITY_CALCULATION_FAILED;\r\n    }\r\n    \r\n    if (this._frustumData.imageRectangle === undefined) {\r\n        throw 'No imageRectangle information passed in setPrioritizerData';\r\n    }\r\n    \r\n    var exactFrustumLevel = this._frustumData.exactNumResolutionLevelsToCut;\r\n    \r\n    if (this._frustumData.exactNumResolutionLevelsToCut === undefined) {\r\n        throw 'No exactNumResolutionLevelsToCut information passed in ' +\r\n            'setPrioritizerData. Use null if unknown';\r\n    }\r\n    \r\n    var tileWest = this._pixelToCartographicX(\r\n        imagePartParams.minX, imagePartParams);\r\n    var tileEast = this._pixelToCartographicX(\r\n        imagePartParams.maxXExclusive, imagePartParams);\r\n    var tileNorth = this._pixelToCartographicY(\r\n        imagePartParams.minY, imagePartParams);\r\n    var tileSouth = this._pixelToCartographicY(\r\n        imagePartParams.maxYExclusive, imagePartParams);\r\n    \r\n    var tilePixelsWidth =\r\n        imagePartParams.maxXExclusive - imagePartParams.minX;\r\n    var tilePixelsHeight =\r\n        imagePartParams.maxYExclusive - imagePartParams.minY;\r\n    \r\n    var requestToFrustumResolutionRatio;\r\n    var tileLevel = imagePartParams.numResolutionLevelsToCut || 0;\r\n    if (exactFrustumLevel === null) {\r\n        var tileResolutionX = tilePixelsWidth / (tileEast - tileWest);\r\n        var tileResolutionY = tilePixelsHeight / (tileNorth - tileSouth);\r\n        var tileResolution = Math.max(tileResolutionX, tileResolutionY);\r\n        var frustumResolution = this._frustumData.resolution;\r\n        requestToFrustumResolutionRatio = tileResolution / frustumResolution;\r\n    \r\n        if (requestToFrustumResolutionRatio > 2) {\r\n            return PRIORITY_TOO_GOOD_RESOLUTION;\r\n        }\r\n    } else if (tileLevel < exactFrustumLevel) {\r\n        return PRIORITY_TOO_GOOD_RESOLUTION;\r\n    }\r\n    \r\n    var frustumRectangle = this._frustumData.rectangle;\r\n    var intersectionWest = Math.max(frustumRectangle.west, tileWest);\r\n    var intersectionEast = Math.min(frustumRectangle.east, tileEast);\r\n    var intersectionSouth = Math.max(frustumRectangle.south, tileSouth);\r\n    var intersectionNorth = Math.min(frustumRectangle.north, tileNorth);\r\n    \r\n    var intersectionWidth = intersectionEast - intersectionWest;\r\n    var intersectionHeight = intersectionNorth - intersectionSouth;\r\n    \r\n    if (intersectionWidth < 0 || intersectionHeight < 0) {\r\n        return PRIORITY_NOT_IN_FRUSTUM;\r\n    }\r\n    \r\n    if (exactFrustumLevel !== null) {\r\n        if (tileLevel > exactFrustumLevel) {\r\n            return PRIORITY_LOWER_RESOLUTION;\r\n        }\r\n    } else if (tileLevel > 0 && requestToFrustumResolutionRatio < 0.25) {\r\n        return PRIORITY_LOWER_RESOLUTION;\r\n    }\r\n    \r\n    var intersectionArea = intersectionWidth * intersectionHeight;\r\n    var tileArea = (tileEast - tileWest) * (tileNorth - tileSouth);\r\n    var partInFrustum = intersectionArea / tileArea;\r\n    \r\n    if (partInFrustum > 0.99) {\r\n        return PRIORITY_FULLY_IN_FRUSTUM;\r\n    } else if (partInFrustum > 0.7) {\r\n        return PRIORITY_MAJORITY_IN_FRUSTUM;\r\n    } else if (partInFrustum > 0.3) {\r\n        return PRIORITY_PARTIAL_IN_FRUSTUM;\r\n    } else {\r\n        return PRIORITY_MINORITY_IN_FRUSTUM;\r\n    }\r\n};\r\n\r\nFrustumRequestsPrioritizer.prototype._pixelToCartographicX = function pixelToCartographicX(\r\n    x, imagePartParams) {\r\n    \r\n    var relativeX = x / this._frustumData.image.getLevelWidth(\r\n        imagePartParams.numResolutionLevelsToCut);\r\n    \r\n    var imageRectangle = this._frustumData.imageRectangle;\r\n    var rectangleWidth = imageRectangle.east - imageRectangle.west;\r\n    \r\n    var xProjected = imageRectangle.west + relativeX * rectangleWidth;\r\n    return xProjected;\r\n};\r\n\r\nFrustumRequestsPrioritizer.prototype._pixelToCartographicY = function tileToCartographicY(\r\n    y, imagePartParams, image) {\r\n    \r\n    var relativeY = y / this._frustumData.image.getLevelHeight(\r\n        imagePartParams.numResolutionLevelsToCut);\r\n    \r\n    var imageRectangle = this._frustumData.imageRectangle;\r\n    var rectangleHeight = imageRectangle.north - imageRectangle.south;\r\n    \r\n    var yProjected = imageRectangle.north - relativeY * rectangleHeight;\r\n    return yProjected;\r\n};","'use strict';\r\n\r\nvar FrustumRequestsPrioritizer = require('frustumrequestsprioritizer.js');\r\n\r\nmodule.exports = {\r\n    calculateFrustum2DFromBounds: calculateFrustum2DFromBounds,\r\n    createScheduler: createScheduler,\r\n    fixBounds: fixBounds,\r\n    alignParamsToTilesAndLevel: alignParamsToTilesAndLevel,\r\n    getImageImplementation: getImageImplementation,\r\n    getScriptsForWorkerImport: getScriptsForWorkerImport\r\n};\r\n\r\n// Avoid strict mode error\r\nvar globals;\r\n\r\n// Avoid jshint error\r\n/* global self: false */\r\n    \r\nvar log2 = Math.log(2);\r\n\r\nvar imageDecoderFrameworkScript = new AsyncProxy.ScriptsToImportPool();\r\nimageDecoderFrameworkScript.addScriptFromErrorWithStackTrace(new Error());\r\nvar scriptsForWorkerToImport = imageDecoderFrameworkScript.getScriptsForWorkerImport();\r\n\r\nfunction calculateFrustum2DFromBounds(\r\n    bounds, screenSize) {\r\n    \r\n    var screenPixels =\r\n        screenSize.x * screenSize.x + screenSize.y * screenSize.y;\r\n    \r\n    var boundsWidth = bounds.east - bounds.west;\r\n    var boundsHeight = bounds.north - bounds.south;\r\n    var boundsDistance =\r\n        boundsWidth * boundsWidth + boundsHeight * boundsHeight;\r\n    \r\n    var resolution = Math.sqrt(screenPixels / boundsDistance);\r\n    \r\n    var frustumData = {\r\n        resolution: resolution,\r\n        rectangle: bounds,\r\n        \r\n        // Redundant, but enables to avoid already-performed calculation\r\n        screenSize: screenSize\r\n    };\r\n    \r\n    return frustumData;\r\n}\r\n    \r\nfunction createScheduler(\r\n    showLog, prioritizerType, schedulerName, createResource, resourceLimit) {\r\n    \r\n    var prioritizer;\r\n    var scheduler;\r\n    \r\n    if (prioritizerType === undefined) {\r\n        prioritizer = null;\r\n        \r\n        scheduler = new ResourceScheduler.LifoScheduler(\r\n            createResource,\r\n            resourceLimit);\r\n    } else {\r\n        var limitResourceByLowQualityPriority = false;\r\n        \r\n        if (prioritizerType === 'frustum') {\r\n            limitResourceByLowQualityPriority = true;\r\n            prioritizer = new FrustumRequestsPrioritizer();\r\n        } else if (prioritizerType === 'frustumOnly') {\r\n            limitResourceByLowQualityPriority = true;\r\n            prioritizer = new FrustumRequestsPrioritizer(\r\n                /*isAbortRequestsNotInFrustum=*/true,\r\n                /*isPrioritizeLowQualityStage=*/true);\r\n        } else {\r\n            prioritizer = prioritizerType;\r\n        }\r\n        \r\n        var options = {\r\n            schedulerName: schedulerName,\r\n            showLog: showLog\r\n        };\r\n        \r\n        if (limitResourceByLowQualityPriority) {\r\n            options.resourceGuaranteedForHighPriority = resourceLimit - 2;\r\n            options.highPriorityToGuaranteeResource =\r\n                prioritizer.minimalLowQualityPriority;\r\n        }\r\n        \r\n        scheduler = new ResourceScheduler.PriorityScheduler(\r\n            createResource,\r\n            resourceLimit,\r\n            prioritizer,\r\n            options);\r\n    }\r\n    \r\n    return {\r\n        prioritizer: prioritizer,\r\n        scheduler: scheduler\r\n    };\r\n}\r\n    \r\nfunction fixBounds(bounds, image, adaptProportions) {\r\n    if (!adaptProportions) {\r\n        return;\r\n    }\r\n\r\n    var rectangleWidth = bounds.east - bounds.west;\r\n    var rectangleHeight = bounds.north - bounds.south;\r\n\r\n    var pixelsAspectRatio =\r\n        image.getLevelWidth() / image.getLevelHeight();\r\n    var rectangleAspectRatio = rectangleWidth / rectangleHeight;\r\n    \r\n    if (pixelsAspectRatio < rectangleAspectRatio) {\r\n        var oldWidth = rectangleWidth;\r\n        rectangleWidth = rectangleHeight * pixelsAspectRatio;\r\n        var substractFromWidth = oldWidth - rectangleWidth;\r\n        \r\n        bounds.east -= substractFromWidth / 2;\r\n        bounds.west += substractFromWidth / 2;\r\n    } else {\r\n        var oldHeight = rectangleHeight;\r\n        rectangleHeight = rectangleWidth / pixelsAspectRatio;\r\n        var substractFromHeight = oldHeight - rectangleHeight;\r\n        \r\n        bounds.north -= substractFromHeight / 2;\r\n        bounds.south += substractFromHeight / 2;\r\n    }\r\n}\r\n\r\nfunction alignParamsToTilesAndLevel(\r\n    region, imageDecoder) {\r\n    \r\n    var sizesCalculator = imageDecoder._getSizesCalculator();\r\n    var tileWidth = imageDecoder.getTileWidth();\r\n    var tileHeight = imageDecoder.getTileHeight();\r\n    \r\n    var regionMinX = region.minX;\r\n    var regionMinY = region.minY;\r\n    var regionMaxX = region.maxXExclusive;\r\n    var regionMaxY = region.maxYExclusive;\r\n    var screenWidth = region.screenWidth;\r\n    var screenHeight = region.screenHeight;\r\n    \r\n    var isValidOrder = regionMinX < regionMaxX && regionMinY < regionMaxY;\r\n    if (!isValidOrder) {\r\n        throw 'Parameters order is invalid';\r\n    }\r\n    \r\n    if (regionMaxX < 0 || regionMinX >= sizesCalculator.getLevelWidth() ||\r\n        regionMaxY < 0 || regionMinY >= sizesCalculator.getLevelHeight()) {\r\n        \r\n        return null;\r\n    }\r\n    \r\n    var maxLevel =\r\n        sizesCalculator.getDefaultNumResolutionLevels() - 1;\r\n\r\n    var levelX = Math.log((regionMaxX - regionMinX) / screenWidth ) / log2;\r\n    var levelY = Math.log((regionMaxY - regionMinY) / screenHeight) / log2;\r\n    var level = Math.ceil(Math.min(levelX, levelY));\r\n    level = Math.max(0, Math.min(maxLevel, level));\r\n    \r\n    var levelWidth = sizesCalculator.getLevelWidth(level);\r\n    var imageWidth = sizesCalculator.getLevelWidth();\r\n    var levelHeight = sizesCalculator.getLevelHeight(level);\r\n    var imageHeight = sizesCalculator.getLevelHeight();\r\n    \r\n    var scaleX = imageWidth / levelWidth;\r\n    var scaleY = imageHeight / levelHeight;\r\n    \r\n    var minTileX = Math.floor(regionMinX / (scaleX * tileWidth));\r\n    var minTileY = Math.floor(regionMinY / (scaleY * tileHeight));\r\n    var maxTileX = Math.ceil(regionMaxX / (scaleX * tileWidth));\r\n    var maxTileY = Math.ceil(regionMaxY / (scaleY * tileHeight));\r\n    \r\n    var minX = Math.max(0, Math.min(levelWidth, minTileX * tileWidth));\r\n    var maxX = Math.max(0, Math.min(levelWidth, maxTileX * tileWidth));\r\n    var minY = Math.max(0, Math.min(levelHeight, minTileY * tileHeight));\r\n    var maxY = Math.max(0, Math.min(levelHeight, maxTileY * tileHeight));\r\n    \r\n    var imagePartParams = {\r\n        minX: minX,\r\n        minY: minY,\r\n        maxXExclusive: maxX,\r\n        maxYExclusive: maxY,\r\n        numResolutionLevelsToCut: level\r\n    };\r\n    \r\n    var positionInImage = {\r\n        minX: minX * scaleX,\r\n        minY: minY * scaleY,\r\n        maxXExclusive: maxX * scaleX,\r\n        maxYExclusive: maxY * scaleY\r\n    };\r\n    \r\n    return {\r\n        imagePartParams: imagePartParams,\r\n        positionInImage: positionInImage\r\n    };\r\n}\r\n\r\nfunction getImageImplementation(imageImplementationClassName) {\r\n    return  (window && window[imageImplementationClassName]) ||\r\n            (globals && globals[imageImplementationClassName]) ||\r\n            (self && self[imageImplementationClassName]);\r\n}\r\n\r\nfunction getScriptsForWorkerImport(imageImplementation, options) {\r\n    return scriptsForWorkerToImport.concat(\r\n        imageImplementation.getScriptsToImport());\r\n}","'use strict';\r\n\r\nvar LinkedList = (function LinkedListClosure() {\r\n    function LinkedList() {\r\n        this._first = { _prev: null, _parent: this };\r\n        this._last = { _next: null, _parent: this };\r\n        this._count = 0;\r\n        \r\n        this._last._prev = this._first;\r\n        this._first._next = this._last;\r\n    }\r\n    \r\n    LinkedList.prototype.add = function add(value, addBefore) {\r\n        if (addBefore === null || addBefore === undefined) {\r\n            addBefore = this._last;\r\n        }\r\n        \r\n        this._validateIteratorOfThis(addBefore);\r\n        \r\n        ++this._count;\r\n        \r\n        var newNode = {\r\n            _value: value,\r\n            _next: addBefore,\r\n            _prev: addBefore._prev,\r\n            _parent: this\r\n        };\r\n        \r\n        newNode._prev._next = newNode;\r\n        addBefore._prev = newNode;\r\n        \r\n        return newNode;\r\n    };\r\n    \r\n    LinkedList.prototype.remove = function remove(iterator) {\r\n        this._validateIteratorOfThis(iterator);\r\n        \r\n        --this._count;\r\n        \r\n        iterator._prev._next = iterator._next;\r\n        iterator._next._prev = iterator._prev;\r\n        iterator._parent = null;\r\n    };\r\n    \r\n    LinkedList.prototype.getValue = function getValue(iterator) {\r\n        this._validateIteratorOfThis(iterator);\r\n        \r\n        return iterator._value;\r\n    };\r\n    \r\n    LinkedList.prototype.getFirstIterator = function getFirstIterator() {\r\n        var iterator = this.getNextIterator(this._first);\r\n        return iterator;\r\n    };\r\n    \r\n    LinkedList.prototype.getLastIterator = function getFirstIterator() {\r\n        var iterator = this.getPrevIterator(this._last);\r\n        return iterator;\r\n    };\r\n    \r\n    LinkedList.prototype.getNextIterator = function getNextIterator(iterator) {\r\n        this._validateIteratorOfThis(iterator);\r\n\r\n        if (iterator._next === this._last) {\r\n            return null;\r\n        }\r\n        \r\n        return iterator._next;\r\n    };\r\n    \r\n    LinkedList.prototype.getPrevIterator = function getPrevIterator(iterator) {\r\n        this._validateIteratorOfThis(iterator);\r\n\r\n        if (iterator._prev === this._first) {\r\n            return null;\r\n        }\r\n        \r\n        return iterator._prev;\r\n    };\r\n    \r\n    LinkedList.prototype.getCount = function getCount() {\r\n        return this._count;\r\n    };\r\n    \r\n    LinkedList.prototype._validateIteratorOfThis =\r\n        function validateIteratorOfThis(iterator) {\r\n        \r\n        if (iterator._parent !== this) {\r\n            throw 'iterator must be of the current LinkedList';\r\n        }\r\n    };\r\n    \r\n    return LinkedList;\r\n})();","'use strict';\r\n\r\n// Suppress \"Unnecessary directive 'use strict'\" for the slaveScriptContent function\r\n/*jshint -W034 */\r\n\r\nmodule.exports.getScriptUrl = function getScriptUrl() {\r\n    return slaveScriptUrl;\r\n};\r\n\r\nvar slaveScriptBlob = new Blob(\r\n    ['(', slaveScriptContent.toString(), ')()'],\r\n    { type: 'application/javascript' });\r\nvar slaveScriptUrl = URL.createObjectURL(slaveScriptBlob);\r\n\r\nfunction slaveScriptContent() {\r\n    'use strict';\r\n    \r\n    var isReady = false;\r\n\r\n    AsyncProxy.AsyncProxySlave.setBeforeOperationListener(beforeOperationListener);\r\n\r\n    function beforeOperationListener(operationType, operationName, args) {\r\n        /* jshint validthis: true */\r\n        \r\n        if (operationType !== 'callback' || operationName !== 'statusCallback') {\r\n            return;\r\n        }\r\n        \r\n        if (isReady || !args[0].isReady) {\r\n            return null;\r\n        }\r\n        \r\n        var sizes = this._getSizesParams();\r\n        isReady = true;\r\n        \r\n        AsyncProxy.AsyncProxySlave.sendUserDataToMaster(sizes);\r\n    }\r\n}","'use strict';\r\n\r\nmodule.exports = WorkerProxyFetchManager;\r\n\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\nvar sendImageParametersToMaster = require('sendimageparameterstomaster.js');\r\n\r\nfunction WorkerProxyFetchManager(imageImplementationClassName, options) {\r\n    this._imageWidth = null;\r\n    this._imageHeight = null;\r\n    this._sizesParams = null;\r\n    this._currentStatusCallbackWrapper = null;\r\n    \r\n    var ctorArgs = [options];\r\n    \r\n    this._imageImplementation = imageHelperFunctions.getImageImplementation(imageImplementationClassName);\r\n\r\n    var scriptsToImport = imageHelperFunctions.getScriptsForWorkerImport(\r\n        this._imageImplementation, options);\r\n    scriptsToImport = scriptsToImport.concat([sendImageParametersToMaster.getScriptUrl()]);\r\n    \r\n    this._workerHelper = new AsyncProxy.AsyncProxyMaster(\r\n        scriptsToImport, 'FetchManager', ctorArgs);\r\n    \r\n    var boundUserDataHandler = this._userDataHandler.bind(this);\r\n    this._workerHelper.setUserDataHandler(boundUserDataHandler);\r\n}\r\n\r\nWorkerProxyFetchManager.prototype.setStatusCallback = function setStatusCallback(statusCallback) {\r\n    if (this._currentStatusCallbackWrapper !== null) {\r\n        this._workerHelper.freeCallback(this._currentStatusCallbackWrapper);\r\n    }\r\n    \r\n    var callbackWrapper = this._workerHelper.wrapCallbackFromMasterSide(\r\n        statusCallback, 'statusCallback', /*isMultipleTimeCallback=*/true);\r\n    \r\n    this._currentStatusCallbackWrapper = callbackWrapper;\r\n    this._workerHelper.callFunction('setStatusCallback', [callbackWrapper]);\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.open = function open(url) {\r\n    this._workerHelper.callFunction('open', [url]);\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.close = function close(closedCallback) {\r\n    var self = this;\r\n    \r\n    var callbackWrapper = this._workerHelper.wrapCallbackFromMasterSide(\r\n        internalClosedCallback, 'closedCallback');\r\n        \r\n    this._workerHelper.callFunction('close', [callbackWrapper]);\r\n    \r\n    function internalClosedCallback() {\r\n        self._workerHelper.terminate();\r\n        \r\n        if (closedCallback !== undefined) {\r\n            closedCallback();\r\n        }\r\n    }\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.createMovableRequestHandle = function createMovableRequestHandle(\r\n    createdCallback) {\r\n    \r\n    var callbackWrapper = this._workerHelper.wrapCallbackFromMasterSide(\r\n        createdCallback,\r\n        'FetchManager_createMovableRequestHandleCallback');\r\n    \r\n    var args = [callbackWrapper];\r\n    this._workerHelper.callFunction('createMovableRequestHandle', args);\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.moveRequest = function moveRequest(\r\n    movableRequestHandle, imagePartParams) {\r\n    \r\n    var args = [movableRequestHandle, imagePartParams];\r\n    this._workerHelper.callFunction('moveRequest', args);\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.createRequest = function createRequest(\r\n    fetchParams,\r\n    callbackThis,\r\n    callback,\r\n    terminatedCallback,\r\n    isOnlyWaitForData,\r\n    requestId) {\r\n    \r\n    //var pathToArrayInPacketsData = [0, 'data', 'buffer'];\r\n    //var pathToHeadersCodestream = [1, 'codestream', 'buffer'];\r\n    //var transferablePaths = [\r\n    //    pathToArrayInPacketsData,\r\n    //    pathToHeadersCodestream\r\n    //];\r\n    \r\n    var transferablePaths = this._imageImplementation.getTransferablePathsOfRequestCallback();\r\n    \r\n    var internalCallbackWrapper =\r\n        this._workerHelper.wrapCallbackFromMasterSide(\r\n            callback.bind(callbackThis),\r\n            'requestTilesProgressiveCallback',\r\n            /*isMultipleTimeCallback=*/true,\r\n            transferablePaths);\r\n    \r\n    var internalTerminatedCallbackWrapper =\r\n        this._workerHelper.wrapCallbackFromMasterSide(\r\n            internalTerminatedCallback,\r\n            'requestTilesProgressiveTerminatedCallback',\r\n            /*isMultipleTimeCallback=*/false);\r\n            \r\n    var args = [\r\n        fetchParams,\r\n        /*callbackThis=*/{ dummyThis: 'dummyThis' },\r\n        internalCallbackWrapper,\r\n        internalTerminatedCallbackWrapper,\r\n        isOnlyWaitForData,\r\n        requestId];\r\n        \r\n    var self = this;\r\n    \r\n    this._workerHelper.callFunction('createRequest', args);\r\n    \r\n    function internalTerminatedCallback(isAborted) {\r\n        self._workerHelper.freeCallback(internalCallbackWrapper);\r\n        terminatedCallback.call(callbackThis, isAborted);\r\n    }\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.manualAbortNonMovableRequest = function manualAbortNonMovableRequest(\r\n    requestId) {\r\n    \r\n    var args = [requestId];\r\n    this._workerHelper.callFunction(\r\n        'manualAbortNonMovableRequest', args);\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.setIsProgressiveRequest = function setIsProgressiveRequest(\r\n    requestId, isProgressive) {\r\n    \r\n    var args = [requestId, isProgressive];\r\n    this._workerHelper.callFunction('setIsProgressiveRequest', args);\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.setServerRequestPrioritizerData =\r\n    function setServerRequestPrioritizerData(prioritizerData) {\r\n    \r\n    this._workerHelper.callFunction(\r\n        'setServerRequestPrioritizerData',\r\n        [ prioritizerData ],\r\n        { isSendImmediately: true });\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.reconnect = function reconnect() {\r\n    this._workerHelper.callFunction('reconnect');\r\n};\r\n\r\nWorkerProxyFetchManager.prototype.getSizesParams = function getSizesParams() {\r\n    if (this._sizesParams === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n    \r\n    return this._sizesParams;\r\n};\r\n\r\nWorkerProxyFetchManager.prototype._userDataHandler = function userDataHandler(sizesParams) {\r\n    this._sizesParams = sizesParams;\r\n};","'use strict';\r\n\r\nmodule.exports = WorkerProxyImageDecoder;\r\n\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\nvar sendImageParametersToMaster = require('sendimageparameterstomaster.js');\r\n\r\nfunction WorkerProxyImageDecoder(imageImplementationClassName, options) {\r\n    this._imageWidth = null;\r\n    this._imageHeight = null;\r\n    this._sizesParams = null;\r\n    this._tileWidth = 0;\r\n    this._tileHeight = 0;\r\n    this._currentStatusCallbackWrapper = null;\r\n    \r\n    var ctorArgs = [imageImplementationClassName, options];\r\n\r\n    this._imageImplementation = imageHelperFunctions.getImageImplementation(imageImplementationClassName);\r\n    \r\n    var scriptsToImport = imageHelperFunctions.getScriptsForWorkerImport(\r\n        this._imageImplementation, options);\r\n    scriptsToImport = scriptsToImport.concat([sendImageParametersToMaster.getScriptUrl()]);\r\n\r\n    this._workerHelper = new AsyncProxy.AsyncProxyMaster(\r\n        scriptsToImport, 'ImageDecoder', ctorArgs);\r\n    \r\n    var boundUserDataHandler = this._userDataHandler.bind(this);\r\n    this._workerHelper.setUserDataHandler(boundUserDataHandler);\r\n}\r\n\r\nWorkerProxyImageDecoder.prototype.setStatusCallback = function setStatusCallback(statusCallback) {\r\n    if (this._currentStatusCallbackWrapper !== null) {\r\n        this._workerHelper.freeCallback(this._currentStatusCallbackWrapper);\r\n    }\r\n    \r\n    var callbackWrapper = this._workerHelper.wrapCallbackFromMasterSide(\r\n        statusCallback, 'statusCallback', /*isMultipleTimeCallback=*/true);\r\n    \r\n    this._currentStatusCallbackWrapper = callbackWrapper;\r\n    this._workerHelper.callFunction('setStatusCallback', [callbackWrapper]);\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.open = function open(url) {\r\n    this._workerHelper.callFunction('open', [url]);\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.close = function close(closedCallback) {\r\n    var self = this;\r\n    \r\n    var callbackWrapper = this._workerHelper.wrapCallbackFromMasterSide(\r\n        internalClosedCallback, 'closedCallback');\r\n        \r\n    this._workerHelper.callFunction('close', [callbackWrapper]);\r\n    \r\n    function internalClosedCallback() {\r\n        self._workerHelper.terminate();\r\n        \r\n        if (closedCallback !== undefined) {\r\n            closedCallback();\r\n        }\r\n    }\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.getLevelWidth = function getLevelWidth(numResolutionLevelsToCut) {\r\n    if (this._sizesCalculator === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n\r\n    var width = this._sizesCalculator.getLevelWidth(\r\n        numResolutionLevelsToCut);\r\n    return width;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.getLevelHeight = function getLevelHeight(numResolutionLevelsToCut) {\r\n    if (this._sizesCalculator === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n    \r\n    var height = this._sizesCalculator.getLevelHeight(\r\n        numResolutionLevelsToCut);\r\n    return height;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.getTileWidth = function getTileWidth() {\r\n    if (this._tileWidth === 0) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n\r\n    return this._tileWidth;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.getTileHeight = function getTileHeight() {\r\n    if (this._tileHeight === 0) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n\r\n    return this._tileHeight;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.getDefaultNumResolutionLevels = function getDefaultNumResolutionLevels() {\r\n    if (this._sizesCalculator === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n    \r\n    var numLevels = this._sizesCalculator.getDefaultNumResolutionLevels();\r\n    return numLevels;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.getDefaultNumQualityLayers = function getDefaultNumQualityLayers() {\r\n    if (this._sizesCalculator === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n    \r\n    var numLayers = this._sizesCalculator.getDefaultNumQualityLayers();\r\n    return numLayers;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.createMovableRequestHandle = function createMovableRequestHandle(\r\n    createdCallback) {\r\n    \r\n    var callbackWrapper = this._workerHelper.wrapCallbackFromMasterSide(\r\n        createdCallback, 'ImageDecoder_createMovableRequestHandleCallback');\r\n    \r\n    var args = [callbackWrapper];\r\n    this._workerHelper.callFunction('createMovableRequestHandle', args);\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.requestPixels = function requestPixels(imagePartParams) {\r\n    var pathToPixelsArray = ['pixels', 'buffer'];\r\n    var transferables = [pathToPixelsArray];\r\n    \r\n    var args = [imagePartParams];\r\n    \r\n    this._workerHelper.callFunction('requestPixels', args, {\r\n        isReturnPromise: true,\r\n        pathsToTransferablesInPromiseResult: transferables\r\n    });\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.requestPixelsProgressive = function requestPixelsProgressive(\r\n    imagePartParams,\r\n    callback,\r\n    terminatedCallback,\r\n    imagePartParamsNotNeeded,\r\n    movableRequestHandleToChange) {\r\n    \r\n    var transferables;\r\n    \r\n    // NOTE: Cannot pass it as transferables because it is passed to all\r\n    // listener callbacks, thus after the first one the buffer is not valid\r\n    \r\n    //var pathToPixelsArray = [0, 'pixels', 'buffer'];\r\n    //transferables = [pathToPixelsArray];\r\n    \r\n    var internalCallbackWrapper =\r\n        this._workerHelper.wrapCallbackFromMasterSide(\r\n            callback,\r\n            'requestPixelsProgressiveCallback',\r\n            /*isMultipleTimeCallback=*/true,\r\n            transferables);\r\n    \r\n    var internalTerminatedCallbackWrapper =\r\n        this._workerHelper.wrapCallbackFromMasterSide(\r\n            internalTerminatedCallback,\r\n            'requestPixelsProgressiveTerminatedCallback',\r\n            /*isMultipleTimeCallback=*/false);\r\n            \r\n    var args = [\r\n        imagePartParams,\r\n        internalCallbackWrapper,\r\n        internalTerminatedCallbackWrapper,\r\n        imagePartParamsNotNeeded,\r\n        movableRequestHandleToChange];\r\n    \r\n    this._workerHelper.callFunction('requestPixelsProgressive', args);\r\n        \r\n    var self = this;\r\n    \r\n    function internalTerminatedCallback(isAborted) {\r\n        self._workerHelper.freeCallback(internalCallbackWrapper);\r\n        \r\n        terminatedCallback(isAborted);\r\n    }\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.setServerRequestPrioritizerData =\r\n    function setServerRequestPrioritizerData(prioritizerData) {\r\n    \r\n    this._workerHelper.callFunction(\r\n        'setServerRequestPrioritizerData',\r\n        [ prioritizerData ],\r\n        { isSendImmediately: true });\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.setDecodePrioritizerData =\r\n    function setDecodePrioritizerData(prioritizerData) {\r\n    \r\n    this._workerHelper.callFunction(\r\n        'setDecodePrioritizerData',\r\n        [ prioritizerData ],\r\n        { isSendImmediately: true });\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype.reconnect = function reconnect() {\r\n    this._workerHelper.callFunction('reconnect');\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype._getSizesCalculator = function getSizesCalculator() {\r\n    if (this._sizesCalculator === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n    \r\n    return this._sizesCalculator;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype._getSizesParams = function getSizesParams() {\r\n    if (this._sizesParams === null) {\r\n        throw 'Image is not ready yet';\r\n    }\r\n    \r\n    return this._sizesParams;\r\n};\r\n\r\nWorkerProxyImageDecoder.prototype._userDataHandler = function userDataHandler(sizesParams) {\r\n    this._sizesParams = sizesParams;\r\n    this._tileWidth = sizesParams.applicativeTileWidth;\r\n    this._tileHeight = sizesParams.applicativeTileHeight;\r\n    this._sizesCalculator = this._imageImplementation.createImageParamsRetriever(\r\n        sizesParams.imageParams);\r\n};","'use strict';\r\n\r\n// Suppress \"Unnecessary directive 'use strict'\" for the slaveScriptContent function\r\n/*jshint -W034 */\r\n\r\n/* global self: false */\r\n\r\nmodule.exports = WorkerProxyPixelsDecoder;\r\n\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\n\r\nvar decoderSlaveScriptBlob = new Blob(\r\n    ['(', decoderSlaveScriptBody.toString(), ')()'],\r\n    { type: 'application/javascript' });\r\nvar decoderSlaveScriptUrl = URL.createObjectURL(decoderSlaveScriptBlob);\r\n\r\nfunction WorkerProxyPixelsDecoder(imageImplementationClassName) {\r\n    this._imageImplementation = imageHelperFunctions.getImageImplementation(\r\n        imageImplementationClassName);\r\n    \r\n    var scriptsToImport = imageHelperFunctions.getScriptsForWorkerImport(\r\n        this._imageImplementation);\r\n    scriptsToImport = scriptsToImport.concat([decoderSlaveScriptUrl]);\r\n    \r\n    var args = [imageImplementationClassName];\r\n    \r\n    this._workerHelper = new AsyncProxy.AsyncProxyMaster(\r\n        scriptsToImport,\r\n        'ArbitraryClassName',\r\n        args);\r\n}\r\n\r\nWorkerProxyPixelsDecoder.prototype.decode = function decode(dataForDecode) {\r\n    var transferables = this._imageImplementation.getTransferablesOfRequestCallback(dataForDecode);\r\n    var resultTransferables = [0, 'pixels', 'buffer'];\r\n    \r\n    var args = [dataForDecode];\r\n    var options = {\r\n        transferables: transferables,\r\n        pathsToTransferablesInPromiseResult: resultTransferables,\r\n        isReturnPromise: true\r\n    };\r\n    \r\n    return this._workerHelper.callFunction('decode', args, options);\r\n};\r\n\r\nfunction decoderSlaveScriptBody() {\r\n    'use strict';\r\n\r\n    AsyncProxy.AsyncProxySlave.setSlaveSideCreator(createDecoder);\r\n\r\n    function createDecoder(imageImplementationClassName) {\r\n        var imageImplementation = self[imageImplementationClassName];\r\n        return imageImplementation.createDecoder();\r\n    }\r\n}","'use strict';\r\n\r\nmodule.exports = ViewerImageDecoder;\r\n\r\nvar ImageDecoder = require('imagedecoder.js');\r\nvar WorkerProxyImageDecoder = require('workerproxyimagedecoder.js');\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\n\r\nvar PENDING_CALL_TYPE_PIXELS_UPDATED = 1;\r\nvar PENDING_CALL_TYPE_REPOSITION = 2;\r\n\r\nvar REGION_OVERVIEW = 0;\r\nvar REGION_DYNAMIC = 1;\r\n\r\nfunction ViewerImageDecoder(canvasUpdatedCallback, options) {\r\n    this._canvasUpdatedCallback = canvasUpdatedCallback;\r\n    \r\n    this._adaptProportions = options.adaptProportions;\r\n    this._cartographicBounds = options.cartographicBounds;\r\n    this._maxNumQualityLayers = options.maxNumQualityLayers;\r\n    this._isMainImageOnUi = options.isMainImageOnUi;\r\n    this._showLog = options.showLog;\r\n    this._allowMultipleChannelsInSession =\r\n        options.allowMultipleChannelsInSession;\r\n    this._minFunctionCallIntervalMilliseconds =\r\n        options.minFunctionCallIntervalMilliseconds;\r\n        \r\n    this._lastRequestIndex = 0;\r\n    this._pendingUpdateViewArea = null;\r\n    this._regions = [];\r\n    this._targetCanvas = null;\r\n    \r\n    this._callPendingCallbacksBound = this._callPendingCallbacks.bind(this);\r\n    this._createdRequestHandleBound = this._createdRequestHandle.bind(this);\r\n    \r\n    this._pendingCallbacksIntervalHandle = 0;\r\n    this._pendingCallbackCalls = [];\r\n    this._exceptionCallback = null;\r\n    this._canShowDynamicRegion = false;\r\n    \r\n    if (this._cartographicBounds === undefined) {\r\n        this._cartographicBounds = {\r\n            west: -175.0,\r\n            east: 175.0,\r\n            south: -85.0,\r\n            north: 85.0\r\n        };\r\n    }\r\n    \r\n    if (this._adaptProportions === undefined) {\r\n        this._adaptProportions = true;\r\n    }\r\n    \r\n    var ImageType = this._isMainImageOnUi ?\r\n        ImageDecoder: WorkerProxyImageDecoder;\r\n        \r\n    this._image = new ImageType({\r\n        serverRequestPrioritizer: 'frustumOnly',\r\n        decodePrioritizer: 'frustumOnly',\r\n        showLog: this._showLog\r\n        });\r\n    \r\n    this._image.setStatusCallback(this._internalStatusCallback.bind(this));\r\n}\r\n\r\nViewerImageDecoder.prototype.setExceptionCallback = function setExceptionCallback(exceptionCallback) {\r\n    this._exceptionCallback = exceptionCallback;\r\n};\r\n    \r\nViewerImageDecoder.prototype.open = function open(url) {\r\n    this._image.open(url);\r\n};\r\n\r\nViewerImageDecoder.prototype.close = function close() {\r\n    this._image.close();\r\n    this._isReady = false;\r\n    this._canShowDynamicRegion = false;\r\n    this._targetCanvas = null;\r\n};\r\n\r\nViewerImageDecoder.prototype.setTargetCanvas = function setTargetCanvas(canvas) {\r\n    this._targetCanvas = canvas;\r\n};\r\n\r\nViewerImageDecoder.prototype.updateViewArea = function updateViewArea(frustumData) {\r\n    if (this._targetCanvas === null) {\r\n        throw 'Cannot update dynamic region before setTargetCanvas()';\r\n    }\r\n    \r\n    if (!this._canShowDynamicRegion) {\r\n        this._pendingUpdateViewArea = frustumData;\r\n        \r\n        return;\r\n    }\r\n    \r\n    var bounds = frustumData.rectangle;\r\n    var screenSize = frustumData.screenSize;\r\n    \r\n    var regionParams = {\r\n        minX: bounds.west * this._scaleX + this._translateX,\r\n        minY: bounds.north * this._scaleY + this._translateY,\r\n        maxXExclusive: bounds.east * this._scaleX + this._translateX,\r\n        maxYExclusive: bounds.south * this._scaleY + this._translateY,\r\n        screenWidth: screenSize.x,\r\n        screenHeight: screenSize.y\r\n    };\r\n    \r\n    var alignedParams =\r\n        imageHelperFunctions.alignParamsToTilesAndLevel(\r\n            regionParams, this._image);\r\n    \r\n    var isOutsideScreen = alignedParams === null;\r\n    if (isOutsideScreen) {\r\n        return;\r\n    }\r\n    \r\n    alignedParams.imagePartParams.maxNumQualityLayers = this._maxNumQualityLayers;\r\n\r\n    var isSameRegion =\r\n        this._dynamicFetchParams !== undefined &&\r\n        this._isImagePartsEqual(\r\n            alignedParams.imagePartParams,\r\n            this._dynamicFetchParams.imagePartParams);\r\n    \r\n    if (isSameRegion) {\r\n        return;\r\n    }\r\n    \r\n    frustumData.imageRectangle = this._cartographicBoundsFixed;\r\n    frustumData.exactNumResolutionLevelsToCut =\r\n        alignedParams.imagePartParams.numResolutionLevelsToCut;\r\n    \r\n    this._image.setDecodePrioritizerData(frustumData);\r\n    this._image.setServerRequestPrioritizerData(frustumData);\r\n\r\n    this._dynamicFetchParams = alignedParams;\r\n    \r\n    var startMovableRequestOnTerminated = false;\r\n    var moveExistingRequest = !this._allowMultipleChannelsInSession;\r\n    this._fetch(\r\n        REGION_DYNAMIC,\r\n        alignedParams,\r\n        startMovableRequestOnTerminated,\r\n        moveExistingRequest);\r\n};\r\n\r\nViewerImageDecoder.prototype._isImagePartsEqual = function isImagePartsEqual(first, second) {\r\n    var isEqual =\r\n        this._dynamicFetchParams !== undefined &&\r\n        first.minX === second.minX &&\r\n        first.minY === second.minY &&\r\n        first.maxXExclusive === second.maxXExclusive &&\r\n        first.maxYExclusive === second.maxYExclusive &&\r\n        first.numResolutionLevelsToCut === second.numResolutionLevelsToCut;\r\n    \r\n    return isEqual;\r\n};\r\n\r\nViewerImageDecoder.prototype._fetch = function fetch(\r\n    regionId,\r\n    fetchParams,\r\n    startMovableRequestOnTerminated,\r\n    moveExistingRequest) {\r\n    \r\n    var requestIndex = ++this._lastRequestIndex;\r\n    \r\n    var imagePartParams = fetchParams.imagePartParams;\r\n    imagePartParams.requestPriorityData =\r\n        imagePartParams.requestPriorityData || {};\r\n    \r\n    imagePartParams.requestPriorityData.requestIndex = requestIndex;\r\n\r\n    var minX = fetchParams.positionInImage.minX;\r\n    var minY = fetchParams.positionInImage.minY;\r\n    var maxX = fetchParams.positionInImage.maxXExclusive;\r\n    var maxY = fetchParams.positionInImage.maxYExclusive;\r\n    \r\n    var west = (minX - this._translateX) / this._scaleX;\r\n    var east = (maxX - this._translateX) / this._scaleX;\r\n    var north = (minY - this._translateY) / this._scaleY;\r\n    var south = (maxY - this._translateY) / this._scaleY;\r\n    \r\n    var position = {\r\n        west: west,\r\n        east: east,\r\n        north: north,\r\n        south: south\r\n    };\r\n    \r\n    var canReuseOldData = false;\r\n    var fetchParamsNotNeeded;\r\n    \r\n    var region = this._regions[regionId];\r\n    if (region !== undefined) {\r\n        var newResolution = imagePartParams.numResolutionLevelsToCut;\r\n        var oldResolution = region.imagePartParams.numResolutionLevelsToCut;\r\n        \r\n        canReuseOldData = newResolution === oldResolution;\r\n        \r\n        if (canReuseOldData && region.isDone) {\r\n            fetchParamsNotNeeded = [ region.imagePartParams ];\r\n        }\r\n\r\n        if (regionId !== REGION_OVERVIEW) {\r\n            var addedPendingCall = this._checkIfRepositionNeeded(\r\n                region, imagePartParams, position);\r\n            \r\n            if (addedPendingCall) {\r\n                this._notifyNewPendingCalls();\r\n            }\r\n        }\r\n    }\r\n    \r\n    var self = this;\r\n    \r\n    var movableRequest = moveExistingRequest ?\r\n        this._movableRequestHandle: undefined;\r\n\r\n    this._image.requestPixelsProgressive(\r\n        fetchParams.imagePartParams,\r\n        callback,\r\n        terminatedCallback,\r\n        fetchParamsNotNeeded,\r\n        movableRequest);\r\n    \r\n    function callback(decoded) {\r\n        self._tilesDecodedCallback(\r\n            regionId,\r\n            fetchParams,\r\n            position,\r\n            decoded);\r\n    }\r\n    \r\n    function terminatedCallback(isAborted) {\r\n        if (isAborted &&\r\n            imagePartParams.requestPriorityData.overrideHighestPriority) {\r\n            \r\n            // NOTE: Bug in kdu_server causes first request to be sent wrongly.\r\n            // Then Chrome raises ERR_INVALID_CHUNKED_ENCODING and the request\r\n            // never returns. Thus perform second request.\r\n            \r\n            self._image.requestPixelsProgressive(\r\n                fetchParams.imagePartParams,\r\n                callback,\r\n                terminatedCallback,\r\n                fetchParamsNotNeeded);\r\n        }\r\n        \r\n        self._fetchTerminatedCallback(\r\n            regionId,\r\n            fetchParams.imagePartParams.requestPriorityData,\r\n            isAborted,\r\n            startMovableRequestOnTerminated);\r\n    }\r\n};\r\n\r\nViewerImageDecoder.prototype._fetchTerminatedCallback = function fetchTerminatedCallback(\r\n    regionId, priorityData, isAborted, startMovableRequestOnTerminated) {\r\n    \r\n    var region = this._regions[regionId];\r\n    if (region === undefined) {\r\n        return;\r\n    }\r\n    \r\n    if (!priorityData.overrideHighestPriority &&\r\n        priorityData.requestIndex !== this._lastRequestIndex) {\r\n    \r\n        return;\r\n    }\r\n    \r\n    region.isDone = !isAborted && this._isReady;\r\n    \r\n    if (startMovableRequestOnTerminated) {\r\n        this._image.createMovableRequestHandle(\r\n            this._createdRequestHandleBound);\r\n    }\r\n};\r\n\r\nViewerImageDecoder.prototype._createdRequestHandle = function createdRequestHandle(requestHandle) {\r\n    this._movableRequestHandle = requestHandle;\r\n    this._startShowingDynamicRegion();\r\n};\r\n\r\nViewerImageDecoder.prototype._startShowingDynamicRegion = function startShowingDynamicRegion() {\r\n    this._canShowDynamicRegion = true;\r\n    \r\n    if (this._pendingUpdateViewArea !== null) {\r\n        this.updateViewArea(this._pendingUpdateViewArea);\r\n        \r\n        this._pendingUpdateViewArea = null;\r\n    }\r\n};\r\n\r\nViewerImageDecoder.prototype._tilesDecodedCallback = function tilesDecodedCallback(\r\n    regionId, fetchParams, position, decoded) {\r\n    \r\n    if (!this._isReady) {\r\n        return;\r\n    }\r\n    \r\n    var region = this._regions[regionId];\r\n    if (region === undefined) {\r\n        region = {};\r\n        this._regions[regionId] = region;\r\n        \r\n        switch (regionId) {\r\n            case REGION_DYNAMIC:\r\n                region.canvas = this._targetCanvas;\r\n                break;\r\n                \r\n            case REGION_OVERVIEW:\r\n                region.canvas = document.createElement('canvas');\r\n                break;\r\n            \r\n            default:\r\n                throw 'Unexpected regionId ' + regionId;\r\n        }\r\n    }\r\n    \r\n    var partParams = fetchParams.imagePartParams;\r\n    if (!partParams.requestPriorityData.overrideHighestPriority &&\r\n        partParams.requestPriorityData.requestIndex < region.currentDisplayRequestIndex) {\r\n        \r\n        return;\r\n    }\r\n    \r\n    this._checkIfRepositionNeeded(region, partParams, position);\r\n        \r\n    this._pendingCallbackCalls.push({\r\n        type: PENDING_CALL_TYPE_PIXELS_UPDATED,\r\n        region: region,\r\n        decoded: decoded\r\n    });\r\n    \r\n    this._notifyNewPendingCalls();\r\n};\r\n\r\nViewerImageDecoder.prototype._checkIfRepositionNeeded = function checkIfRepositionNeeded(\r\n    region, newPartParams, newPosition) {\r\n    \r\n    var oldPartParams = region.imagePartParams;\r\n    var level = newPartParams.numResolutionLevelsToCut;\r\n    \r\n    var needReposition =\r\n        oldPartParams === undefined ||\r\n        oldPartParams.minX !== newPartParams.minX ||\r\n        oldPartParams.minY !== newPartParams.minY ||\r\n        oldPartParams.maxXExclusive !== newPartParams.maxXExclusive ||\r\n        oldPartParams.maxYExclusive !== newPartParams.maxYExclusive ||\r\n        oldPartParams.numResolutionLevelsToCut !== level;\r\n    \r\n    if (!needReposition) {\r\n        return false;\r\n    }\r\n    \r\n    var copyData;\r\n    var intersection;\r\n    var reuseOldData = false;\r\n    if (oldPartParams !== undefined &&\r\n        oldPartParams.numResolutionLevelsToCut === level) {\r\n        \r\n        intersection = {\r\n            minX: Math.max(oldPartParams.minX, newPartParams.minX),\r\n            minY: Math.max(oldPartParams.minY, newPartParams.minY),\r\n            maxX: Math.min(oldPartParams.maxXExclusive, newPartParams.maxXExclusive),\r\n            maxY: Math.min(oldPartParams.maxYExclusive, newPartParams.maxYExclusive)\r\n        };\r\n        reuseOldData =\r\n            intersection.maxX > intersection.minX &&\r\n            intersection.maxY > intersection.minY;\r\n    }\r\n    \r\n    if (reuseOldData) {\r\n        copyData = {\r\n            fromX: intersection.minX - oldPartParams.minX,\r\n            fromY: intersection.minY - oldPartParams.minY,\r\n            toX: intersection.minX - newPartParams.minX,\r\n            toY: intersection.minY - newPartParams.minY,\r\n            width: intersection.maxX - intersection.minX,\r\n            height: intersection.maxY - intersection.minY\r\n        };\r\n    }\r\n    \r\n    region.imagePartParams = newPartParams;\r\n    region.isDone = false;\r\n    region.currentDisplayRequestIndex = newPartParams.requestPriorityData.requestIndex;\r\n    \r\n    var repositionArgs = {\r\n        type: PENDING_CALL_TYPE_REPOSITION,\r\n        region: region,\r\n        position: newPosition,\r\n        copyData: copyData,\r\n        pixelsWidth: newPartParams.maxXExclusive - newPartParams.minX,\r\n        pixelsHeight: newPartParams.maxYExclusive - newPartParams.minY\r\n    };\r\n    \r\n    this._pendingCallbackCalls.push(repositionArgs);\r\n    \r\n    return true;\r\n};\r\n\r\nViewerImageDecoder.prototype._notifyNewPendingCalls = function notifyNewPendingCalls() {\r\n    if (!this._isNearCallbackCalled) {\r\n        this._callPendingCallbacks();\r\n    }\r\n};\r\n\r\nViewerImageDecoder.prototype._callPendingCallbacks = function callPendingCallbacks() {\r\n    if (this._pendingCallbackCalls.length === 0 || !this._isReady) {\r\n        this._isNearCallbackCalled = false;\r\n        return;\r\n    }\r\n    \r\n    if (this._isNearCallbackCalled) {\r\n        clearTimeout(this._pendingCallbacksIntervalHandle);\r\n    }\r\n    \r\n    if (this._minFunctionCallIntervalMilliseconds !== undefined) {\r\n        this._pendingCallbacksIntervalHandle =\r\n            setTimeout(this._callPendingCallbacksBound,\r\n            this._minFunctionCallIntervalMilliseconds);\r\n            \r\n        this._isNearCallbackCalled = true;\r\n    }\r\n\r\n    var newPosition = null;\r\n    \r\n    for (var i = 0; i < this._pendingCallbackCalls.length; ++i) {\r\n        var callArgs = this._pendingCallbackCalls[i];\r\n        \r\n        if (callArgs.type === PENDING_CALL_TYPE_REPOSITION) {\r\n            this._repositionCanvas(callArgs);\r\n            newPosition = callArgs.position;\r\n        } else if (callArgs.type === PENDING_CALL_TYPE_PIXELS_UPDATED) {\r\n            this._pixelsUpdated(callArgs);\r\n        } else {\r\n            throw 'Internal ViewerImageDecoder Error: Unexpected call type ' +\r\n                callArgs.type;\r\n        }\r\n    }\r\n    \r\n    this._pendingCallbackCalls.length = 0;\r\n    \r\n    this._canvasUpdatedCallback(newPosition);\r\n};\r\n\r\nViewerImageDecoder.prototype._pixelsUpdated = function pixelsUpdated(pixelsUpdatedArgs) {\r\n    var region = pixelsUpdatedArgs.region;\r\n    var decoded = pixelsUpdatedArgs.decoded;\r\n    if (decoded.width === 0 || decoded.height === 0) {\r\n        return;\r\n    }\r\n    \r\n    var x = decoded.xInOriginalRequest;\r\n    var y = decoded.yInOriginalRequest;\r\n    \r\n    var context = region.canvas.getContext('2d');\r\n    var imageData = context.createImageData(decoded.width, decoded.height);\r\n    imageData.data.set(decoded.pixels);\r\n    \r\n    context.putImageData(imageData, x, y);\r\n};\r\n\r\nViewerImageDecoder.prototype._repositionCanvas = function repositionCanvas(repositionArgs) {\r\n    var region = repositionArgs.region;\r\n    var position = repositionArgs.position;\r\n    var copyData = repositionArgs.copyData;\r\n    var pixelsWidth = repositionArgs.pixelsWidth;\r\n    var pixelsHeight = repositionArgs.pixelsHeight;\r\n    \r\n    var imageDataToCopy;\r\n    var context = region.canvas.getContext('2d');\r\n    \r\n    if (copyData !== undefined) {\r\n        imageDataToCopy = context.getImageData(\r\n            copyData.fromX, copyData.fromY, copyData.width, copyData.height);\r\n    }\r\n    \r\n    region.canvas.width = pixelsWidth;\r\n    region.canvas.height = pixelsHeight;\r\n    \r\n    if (region !== this._regions[REGION_OVERVIEW]) {\r\n        this._copyOverviewToCanvas(\r\n            context, position, pixelsWidth, pixelsHeight);\r\n    }\r\n    \r\n    if (copyData !== undefined) {\r\n        context.putImageData(imageDataToCopy, copyData.toX, copyData.toY);\r\n    }\r\n    \r\n    region.position = position;\r\n};\r\n\r\nViewerImageDecoder.prototype._copyOverviewToCanvas = function copyOverviewToCanvas(\r\n    context, canvasPosition, canvasPixelsWidth, canvasPixelsHeight) {\r\n    \r\n    var sourcePosition = this._regions[REGION_OVERVIEW].position;\r\n    var sourcePixels =\r\n        this._regions[REGION_OVERVIEW].imagePartParams;\r\n    \r\n    var sourcePixelsWidth =\r\n        sourcePixels.maxXExclusive - sourcePixels.minX;\r\n    var sourcePixelsHeight =\r\n        sourcePixels.maxYExclusive - sourcePixels.minY;\r\n    \r\n    var sourcePositionWidth =\r\n        sourcePosition.east - sourcePosition.west;\r\n    var sourcePositionHeight =\r\n        sourcePosition.north - sourcePosition.south;\r\n        \r\n    var sourceResolutionX =\r\n        sourcePixelsWidth / sourcePositionWidth;\r\n    var sourceResolutionY =\r\n        sourcePixelsHeight / sourcePositionHeight;\r\n    \r\n    var targetPositionWidth =\r\n        canvasPosition.east - canvasPosition.west;\r\n    var targetPositionHeight =\r\n        canvasPosition.north - canvasPosition.south;\r\n        \r\n    var cropWidth = targetPositionWidth * sourceResolutionX;\r\n    var cropHeight = targetPositionHeight * sourceResolutionY;\r\n    \r\n    var cropOffsetPositionX =\r\n        canvasPosition.west - sourcePosition.west;\r\n    var cropOffsetPositionY =\r\n        sourcePosition.north - canvasPosition.north;\r\n        \r\n    var cropPixelOffsetX = cropOffsetPositionX * sourceResolutionX;\r\n    var cropPixelOffsetY = cropOffsetPositionY * sourceResolutionY;\r\n    \r\n    context.drawImage(\r\n        this._regions[REGION_OVERVIEW].canvas,\r\n        cropPixelOffsetX, cropPixelOffsetY, cropWidth, cropHeight,\r\n        0, 0, canvasPixelsWidth, canvasPixelsHeight);\r\n};\r\n\r\nViewerImageDecoder.prototype._internalStatusCallback = function statusCallback(status) {\r\n    if (this._exceptionCallback !== null && status.exception !== null) {\r\n        this._exceptionCallback(status.exception);\r\n    }\r\n\r\n    if (this._isReady || !status.isReady) {\r\n        return;\r\n    }\r\n    \r\n    this._isReady = true;\r\n    \r\n    var fixedBounds = {\r\n        west: this._cartographicBounds.west,\r\n        east: this._cartographicBounds.east,\r\n        south: this._cartographicBounds.south,\r\n        north: this._cartographicBounds.north\r\n    };\r\n    imageHelperFunctions.fixBounds(\r\n        fixedBounds, this._image, this._adaptProportions);\r\n    this._cartographicBoundsFixed = fixedBounds;\r\n    \r\n    var imageWidth = this._image.getLevelWidth();\r\n    var imageHeight = this._image.getLevelHeight();\r\n\r\n    var rectangleWidth = fixedBounds.east - fixedBounds.west;\r\n    var rectangleHeight = fixedBounds.north - fixedBounds.south;\r\n    this._scaleX = imageWidth / rectangleWidth;\r\n    this._scaleY = -imageHeight / rectangleHeight;\r\n    \r\n    this._translateX = -fixedBounds.west * this._scaleX;\r\n    this._translateY = -fixedBounds.north * this._scaleY;\r\n    \r\n    var overviewParams = {\r\n        minX: 0,\r\n        minY: 0,\r\n        maxXExclusive: imageWidth,\r\n        maxYExclusive: imageHeight,\r\n        screenWidth: 1,\r\n        screenHeight: 1\r\n    };\r\n    \r\n    var overviewAlignedParams =\r\n        imageHelperFunctions.alignParamsToTilesAndLevel(\r\n            overviewParams, this._image);\r\n            \r\n    overviewAlignedParams.imagePartParams.requestPriorityData =\r\n        overviewAlignedParams.imagePartParams.requestPriorityData || {};\r\n    \r\n    overviewAlignedParams.imagePartParams.requestPriorityData.overrideHighestPriority = true;\r\n    overviewAlignedParams.imagePartParams.maxNumQualityLayers = 1;\r\n    \r\n    var startMovableRequestOnTerminated =\r\n        !this._allowMultipleChannelsInSession;\r\n        \r\n    this._fetch(\r\n        REGION_OVERVIEW,\r\n        overviewAlignedParams,\r\n        startMovableRequestOnTerminated);\r\n    \r\n    if (this._allowMultipleChannelsInSession) {\r\n        this._startShowingDynamicRegion();\r\n    }\r\n};","'use strict';\r\n\r\nvar ViewerImageDecoder = require('viewerimagedecoder.js');\r\nvar LeafletFrustumCalculator = require('leafletfrustumcalculator.js');\r\n\r\n/* global L: false */\r\n\r\nmodule.exports = L.Class.extend({\r\n    initialize: function initialize(options) {\r\n        this._options = Object.create(options);\r\n        \r\n        if (options.latLngBounds !== undefined) {\r\n            this._options.cartographicBounds = {\r\n                west: options.latLngBounds.getWest(),\r\n                east: options.latLngBounds.getEast(),\r\n                south: options.latLngBounds.getSouth(),\r\n                north: options.latLngBounds.getNorth()\r\n            };\r\n        }\r\n        \r\n        this._targetCanvas = null;\r\n        this._canvasPosition = null;\r\n        this._canvasUpdatedCallbackBound = this._canvasUpdatedCallback.bind(this);\r\n        this._image = null;\r\n        this._exceptionCallback = null;\r\n    },\r\n    \r\n    setExceptionCallback: function setExceptionCallback(exceptionCallback) {\r\n        this._exceptionCallback = exceptionCallback;\r\n        if (this._image !== null) {\r\n            this._image.setExceptionCallback(exceptionCallback);\r\n        }\r\n    },\r\n    \r\n    _createImage: function createImage() {\r\n        if (this._image === null) {\r\n            this._image = new ViewerImageDecoder(\r\n                this._canvasUpdatedCallbackBound,\r\n                this._options);\r\n            \r\n            if (this._exceptionCallback !== null) {\r\n                this._image.setExceptionCallback(this._exceptionCallback);\r\n            }\r\n            \r\n            this._image.open(this._options.url);\r\n        }\r\n    },\r\n\r\n    onAdd: function onAdd(map) {\r\n        if (this._map !== undefined) {\r\n            throw 'Cannot add this layer to two maps';\r\n        }\r\n        \r\n        this._map = map;\r\n        this._createImage();\r\n\r\n        // create a DOM element and put it into one of the map panes\r\n        this._targetCanvas = L.DomUtil.create(\r\n            'canvas', 'image-decoder-layer-canvas leaflet-zoom-animated');\r\n        \r\n        this._image.setTargetCanvas(this._targetCanvas);\r\n        \r\n        this._canvasPosition = null;\r\n            \r\n        map.getPanes().mapPane.appendChild(this._targetCanvas);\r\n\r\n        // add a viewreset event listener for updating layer's position, do the latter\r\n        map.on('viewreset', this._moved, this);\r\n        map.on('move', this._moved, this);\r\n\r\n        if (L.Browser.any3d) {\r\n            map.on('zoomanim', this._animateZoom, this);\r\n        }\r\n\r\n        this._moved();\r\n    },\r\n\r\n    onRemove: function onRemove(map) {\r\n        if (map !== this._map) {\r\n            throw 'Removed from wrong map';\r\n        }\r\n        \r\n        map.off('viewreset', this._moved, this);\r\n        map.off('move', this._moved, this);\r\n        map.off('zoomanim', this._animateZoom, this);\r\n        \r\n        // remove layer's DOM elements and listeners\r\n        map.getPanes().mapPane.removeChild(this._targetCanvas);\r\n        this._targetCanvas = null;\r\n        this._canvasPosition = null;\r\n\r\n        this._map = undefined;\r\n        \r\n        this._image.close();\r\n        this._image = null;\r\n    },\r\n    \r\n    _moved: function () {\r\n        this._moveCanvases();\r\n\r\n        var frustumData = LeafletFrustumCalculator.calculateFrustum(this._map);\r\n        \r\n        this._image.updateViewArea(frustumData);\r\n    },\r\n    \r\n    _canvasUpdatedCallback: function canvasUpdatedCallback(newPosition) {\r\n        if (newPosition !== null) {\r\n            this._canvasPosition = newPosition;\r\n            this._moveCanvases();\r\n        }\r\n    },\r\n    \r\n    _moveCanvases: function moveCanvases() {\r\n        if (this._canvasPosition === null) {\r\n            return;\r\n        }\r\n    \r\n        // update layer's position\r\n        var west = this._canvasPosition.west;\r\n        var east = this._canvasPosition.east;\r\n        var south = this._canvasPosition.south;\r\n        var north = this._canvasPosition.north;\r\n        \r\n        var topLeft = this._map.latLngToLayerPoint([north, west]);\r\n        var bottomRight = this._map.latLngToLayerPoint([south, east]);\r\n        var size = bottomRight.subtract(topLeft);\r\n        \r\n        L.DomUtil.setPosition(this._targetCanvas, topLeft);\r\n        this._targetCanvas.style.width = size.x + 'px';\r\n        this._targetCanvas.style.height = size.y + 'px';\r\n    },\r\n    \r\n    _animateZoom: function animateZoom(options) {\r\n        // NOTE: All method (including using of private method\r\n        // _latLngToNewLayerPoint) was copied from ImageOverlay,\r\n        // as Leaflet documentation recommends.\r\n        \r\n        var west =  this._canvasPosition.west;\r\n        var east =  this._canvasPosition.east;\r\n        var south = this._canvasPosition.south;\r\n        var north = this._canvasPosition.north;\r\n\r\n        var topLeft = this._map._latLngToNewLayerPoint(\r\n            [north, west], options.zoom, options.center);\r\n        var bottomRight = this._map._latLngToNewLayerPoint(\r\n            [south, east], options.zoom, options.center);\r\n        \r\n        var scale = this._map.getZoomScale(options.zoom);\r\n        var size = bottomRight.subtract(topLeft);\r\n        var sizeScaled = size.multiplyBy((1 / 2) * (1 - 1 / scale));\r\n        var origin = topLeft.add(sizeScaled);\r\n        \r\n        this._targetCanvas.style[L.DomUtil.TRANSFORM] =\r\n            L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n    }\r\n});","'use strict';\r\n\r\nvar imageHelperFunctions = require('imagehelperfunctions.js');\r\n\r\nmodule.exports = function calculateFrustum(leafletMap) {\r\n    var screenSize = leafletMap.getSize();\r\n    var bounds = leafletMap.getBounds();\r\n\r\n    var cartographicBounds = {\r\n        west: bounds.getWest(),\r\n        east: bounds.getEast(),\r\n        south: bounds.getSouth(),\r\n        north: bounds.getNorth()\r\n    };\r\n    \r\n    var frustumData = imageHelperFunctions.calculateFrustum2DFromBounds(\r\n        cartographicBounds, screenSize);\r\n\r\n    return frustumData;\r\n};"],"sourceRoot":"/source/"}